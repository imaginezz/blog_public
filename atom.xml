<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>政子的博客</title>
  
  <subtitle>技术|学习|随笔</subtitle>
  <link href="https://blog.zhengi.me/atom.xml" rel="self"/>
  
  <link href="https://blog.zhengi.me/"/>
  <updated>2024-03-23T03:42:57.000Z</updated>
  <id>https://blog.zhengi.me/</id>
  
  <author>
    <name>Jason Bian</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Test Doc</title>
    <link href="https://blog.zhengi.me/elogs/blog_posts/Test%20Doc/"/>
    <id>https://blog.zhengi.me/elogs/blog_posts/Test%20Doc/</id>
    <published>2024-03-03T06:36:19.000Z</published>
    <updated>2024-03-23T03:42:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p><img data-src="/../../../images/elogs/b921c8dd42bc1bcccf1a4d99d08f79e1.png"></p><h2 id="测试2"><a href="#测试2" class="headerlink" title="测试2"></a>测试2</h2><h3 id="测试3"><a href="#测试3" class="headerlink" title="测试3"></a>测试3</h3><p>测试4<br>hello</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;测试&quot;&gt;&lt;a href=&quot;#测试&quot; class=&quot;headerlink&quot; title=&quot;测试&quot;&gt;&lt;/a&gt;测试&lt;/h1&gt;&lt;p&gt;&lt;img data-src=&quot;/../../../images/elogs/b921c8dd42bc1bcccf1a4d99d08f79e1</summary>
      
    
    
    
    <category term="随笔" scheme="https://blog.zhengi.me/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="年终总结" scheme="https://blog.zhengi.me/categories/%E9%9A%8F%E7%AC%94/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="年终总结" scheme="https://blog.zhengi.me/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
    <category term="随笔" scheme="https://blog.zhengi.me/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>2021 这一年</title>
    <link href="https://blog.zhengi.me/year_summary_2021/"/>
    <id>https://blog.zhengi.me/year_summary_2021/</id>
    <published>2022-01-09T10:30:00.000Z</published>
    <updated>2024-03-23T06:03:16.947Z</updated>
    
    <content type="html"><![CDATA[<h1 id="intro"><a href="#intro" class="headerlink" title="intro"></a>intro</h1><p>在抬笔之前，纠结许久，过去的这一年，真的有这么多要记录的东西么，有必要花几个小时的时间去写么？我不知道。但同时，我的鼠标已点开了之前的博客，开始翻看前些年写的文字。看着看着，我找到了许多自己已经不怎么记得，但想起却感到十分温暖的那些瞬间和回忆。虽说都不是什么大事儿，但是如果不记录，它们可能真的就会遗失在记忆的荒野里了。</p><p>所以，我还是要写些文字，来记录我这平凡，也小有起伏的一年时间。</p><span id="more"></span><h1 id="目标回顾"><a href="#目标回顾" class="headerlink" title="目标回顾"></a>目标回顾</h1><p>首先，回忆一下去年立的那些flag吧。</p><ul><li>分享至少 5 篇较为优质的内容<ul><li>目标完全没有达成，一是由于惰性，二是感觉自己积累不足</li></ul></li><li>对领域内技术的认知上有明显提升，具有一定的专业性和深度<ul><li>专业知识确有所增加，但离自己的期望还有差距，算是勉强达成</li></ul></li><li>维持学习状态，保持对世界的好奇心，对世界的认知上更进一步<ul><li>确有长进，但也不多，算是没有原地踏步吧</li></ul></li><li>阅读，至少 5 本较篇幅较长的著作，减少看视频的时间<ul><li>大篇幅的只有一本花了半年才读完的《红楼梦》；看视频时间有所减少，原因是从看变为了听</li></ul></li><li>锻炼身体，体重维持在 80kg 以下<ul><li>体重目标超额达成，但原因却不是锻炼身体</li></ul></li><li>多陪陪家人，每周和家人通话<ul><li>目标也算是基本做到</li></ul></li></ul><p>整体看来，六点Flag，勉强算下来，可以说是完成了一半吧，约等于不及格。</p><p>原因肯定是多方面的，不能单独归咎于时间不够。因为我知道就算是时间充裕，也很有可能无法完成上述任务。所以，今年我决定使用一个更加精确的目标系统——OKR对自己的目标进行量化确定/追踪，并且应当可以按照执行情况修改。希望通过新方法，可以让明年的自己及格吧。具体规划放在文末。</p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>这一年的生活给我最大的感悟就是“无常”。疫情无常，生活无常，生死也无常。</p><p>下面，就以几个生活中的小片段来简要概括这一年吧。</p><h2 id="其一"><a href="#其一" class="headerlink" title="其一"></a>其一</h2><p>年初的第一件大事是乐乐的婚礼。在他的婚礼上，我们这三个从小几乎天天在一起的铁哥们，终于能从天南地北百忙之中，在疫情笼罩下，时隔多年之，后再次聚到了一起。我呢，也终于第一次当了伴郎，第一次正经穿上了西装，也第一次从“台上人”视角见证了好朋友的婚礼。疫情之下，虽然没有大操大办，但几天的相处，让我深刻感受到了乐乐和嫂子的深厚感情。所以这里不说别的，祝福乐乐早得贵子，也祝福剑客早日结婚（相见不易，总得有个由头呀）。</p><div align=center>刚布置好的婚房</div><p><img data-src="/images/posts/year_summary_2021/2021-00.jpg"></p><p>此外，在见面后的聊天中，突然发现童年的好友都已成熟起来：聊天中少了许多幼年时对游戏和故事的痴迷、少年时对宇宙和未来的畅想，却添了对生活的感悟与吐槽，以及对肩上责任的担当。肩膀扛起的东西变重了，脚下也自然就会踏实起来，这或许才是人们仰望天空的底气之所在。</p><div align=center>在家后山上看云</div><p><img data-src="/images/posts/year_summary_2021/2021-01.jpg"></p><h2 id="其二"><a href="#其二" class="headerlink" title="其二"></a>其二</h2><p>虽说现代通讯非常方便，但我们几个也是各自有忙，所以自此一别，再次认真联系，大约是就年底了，原因是他们关心我的心理状况：在奶奶去世后的第三年，从小陪伴到大的另一位亲人——爷爷，也永远离我而去了。</p><p>坏事总是十分突然。当时兰州的疫情刚刚有所好转，各种交通刚刚解封，就得到了爷爷病情突然恶化的消息。也顾不得多想，做完核酸第二天的凌晨，就和姑父驱车从北京赶回家中。</p><div align=center>一路上</div><p><img data-src="/images/posts/year_summary_2021/2021-02.png"></p><p>幸运的是，我的决策是对的，在赶回家的那天晚上，见到了爷爷意识完好情况下的最后一面。他在这种情况下，还是像往日那样，一见面就担心我工作忙，穿的少，吃不好。在得知我一切都好后，他也逐渐安心下来。第二天，他的意识就再也没有清醒起来，生命也随之进入了倒计时。最终，在2021年11月23，他还是永远地离开了我们。那天凌晨六点医院门口的瑟瑟寒风，我一定毕生难忘。</p><p>爷爷一生很不容易。他生于解放前，小时虽然家里穷，但成绩优异，所以家里一路供他读到了初中毕业。后来，因为自然灾害无力负担，就征兵入伍，去了二炮，做了一个挂着空军名号的步兵。随着国家需要，他们一路辗转，从老家来到北京，又从北京到了茫茫戈壁。此后，他们部队在戈壁上克服了种种困难，为我们国家的国防做出了重要贡献。后来，他转业来到了当时为了“备战”和“备荒”而在西北大山深处筹备建立的884。他们再次发扬那个时代艰苦奋斗的精神，遇山开山，遇水架桥，硬是在只长荒草的群山深处，建起了一座现代的大型铜加工厂，为国家生产了许多战略物资。在他退休后，虽然终于不用为工作日夜操劳，却又开始为了我的成长费心费力，这一晃又是二十多年，直到现在。</p><p>而就在我刚力所能及可以养活自己，并且也有一些余力可以让他生活得好一些的时候，他却永远地离开了我。子欲养，却亲不待。</p><p>人这个物种大约就是这样，谁也无法脱开的生死的轮回，每个人都应当看开些。但生死事大，岂不痛哉！</p><div align=center>爷爷的在党50年纪念章</div><p><img data-src="/images/posts/year_summary_2021/2021-03.jpg"></p><p>今年也是建党100周年，在这里我要向爷爷这样为国家建设奉献了一生的老同志们，致以最崇高的敬意！虽然在你们身上没有那些波澜壮阔的功绩，也没有曲折动人的故事，但正是由于千千万万你们的付出，让共和国有底气走到今天，也是千千万万你们所坚持的初心，守住了和传承这个社会的正气。</p><h2 id="其三"><a href="#其三" class="headerlink" title="其三"></a>其三</h2><p>现在，让我把回忆的时间线再次拉回年初，去回忆另外一条主线。</p><p>从年初开始，我进入了频繁去杭州出差的状态。虽说每次的目的地都一样，但随着四季的变化，都有新的风景，好不惬意。比如仲春的龙井茶园、夏日的西子湖畔，还有秋日的大运河滨都让令人着迷。我也终于理解为何有如此多的文人墨客偏爱这里，留下了无数流传青史的千古墨宝。</p><div align=center>2021飞行统计</div><p><img data-src="/images/posts/year_summary_2021/2021-04.png"></p><p>这一年的多次往返让我对这座城市有了许多直观的感受，比如：</p><ul><li>自然和人文风光不必多说，不仅好地方多，而且风景在四时都有所不同；</li><li>但是基础设施相比于北京也还存在不小的差距，不过可以看出一直都在进步</li><li>城市处于扩张阶段，老市民集中在老城区，新市民都在新城区，在新城区能明显感到接纳包容的年轻的城市文化，但老城区却相反</li><li>地价房价上涨很快，后上车的人成本变高，且造就了一批房产富豪</li></ul><p>另外，更重要的是卤蛋也逐渐在这座城市安顿了下来，所以我之后还有大把时间在这里走走转转，期待能有更多更深入的了解。</p><div align=center>烟雨龙井村</div><p><img data-src="/images/posts/year_summary_2021/2021-05.jpg"></p><div align=center>西湖落日</div><p><img data-src="/images/posts/year_summary_2021/2021-06.png"></p><div align=center>繁忙的大运河</div><p><img data-src="/images/posts/year_summary_2021/2021-07.jpg"></p><h2 id="其四"><a href="#其四" class="headerlink" title="其四"></a>其四</h2><p>除此之外，在去年上半年我也经常进行体育锻炼，在周内最常去的地方是公司楼下的大望京公园，而在周末则非奥森公园莫属了。基本每周的跑步距离在15到20km左右，除此之外还会骑车上下班，一天大约能有十几公里。跑步的配速也逐渐从年初拉夸的七分钟，逐渐恢复到了年中的五分多钟。并且通过一起跑步，也和公司里的一些同事有了更多的交流，收获满满。</p><div align=center>某次跑步记录</div><p><img data-src="/images/posts/year_summary_2021/2021-08.jpg"></p><p>虽然我的运动量这么大，但是体重却几乎没什么变化。原因很简单——每天都得吃点好的。</p><div align=center>跑完步当然要吃顿好的犒劳一下自己</div><p><img data-src="/images/posts/year_summary_2021/2021-09.jpg"></p><p>肯定有很多人抱着和我一样的想法：已经这么努力运动了，在饮食上放松一下也没有问题。然而，事情没有这么简单。</p><p>在下半年里，我付出了沉重的代价：告别了火锅，告别了啤酒炸鸡，告别了我最爱的麦当劳，甚至告别了多数肉类。同时，我也告别了熬夜看视频，告别了久坐打游戏，也告别了我最爱的长跑。</p><p>现在看来，效果还行。体重从巅峰的接近85kg降低到了如今的不到75kg，身体也逐渐恢复正常。不过随着体重的减轻，肌肉们也在一同不断流失，但做什么，都总得付出些代价吧。</p><div align=center>下半年的体重变化</div><p><img data-src="/images/posts/year_summary_2021/2021-10.png"></p><p>钱花光了可以再赚，物品丢掉了可以再买，数据消失了都可以再造，但是健康失去了却很难重新恢复，关心之人去世了就更难弥补。正所谓“知易行难”，这些简单的大道理说起来容易，但若没有经历过，却很难真正理解。如今理解了，却也都付出了很重的代价。</p><p>最后，我发现猫咪真的是一个十分神奇的物种，不论什么时候，它们总能让人感到治愈，会让人多一些面对不确定性的勇气，所以就用一张球宝（室友的猫咪）的靓照作为本章的结尾吧。</p><div align=center>球宝一瞥</div><p><img data-src="/images/posts/year_summary_2021/2021-11.png"></p><h1 id="工作-amp-技术"><a href="#工作-amp-技术" class="headerlink" title="工作 &amp; 技术"></a>工作 &amp; 技术</h1><p>坦率地讲，自己在去年工作中的收获是不小的。不仅是技术上做到了真正的入门，还有在心理上具有了一定的主动性。</p><p>回过头来审视从刚入职到现在的这一年半的时间，能明显感到自己从一个刚进入公司时几乎什么都不懂，只会低头自己琢磨，不会跟人沟通，甚至因为担心自己水平差，而感到有些自卑的职场新人，成长为了一个较为自信，能直面问题，从更多角度思考，并跟他人配合，共同解决问题的人。</p><p>我认为入职即将满一年的时候对自己来说是一个很重要的节点，原因很简单，那会儿刚好在年末评定绩效，所以在这段时间里，我终于有机会也不得不好好梳理和思考去年一年在我身上发生的事情，以及我面对事情所采取的态度和行为，并且也能将这些思考和主管进行直接而充分的沟通。什么是好的，什么是不好的，什么之后应该努力避免，什么事情还能做的更好，都逐渐变得明晰。这种明确的反馈对于一个人的成长有很大的帮助。</p><div align=center>部门校招同学培训时的一年香蛋糕</div><p><img data-src="/images/posts/year_summary_2021/2021-12.jpg"></p><p>当然，作为一个工程师，除了上面这些比较“务虚”的成长，一定还得聊聊自己技术的进展。</p><p>祸福相依，虽说自己干自己的，不懂和别人交流不是什么好事，但是也是由于多数时间都在低头琢磨，自己写代码，所以从刚入职到一周年左右时，我大概零零散散为项目提交了大约一万多行不到两万行代码。因为我所编写模块代码和其它模块有很多耦合，所以编码的时候我也被迫几乎阅读了我们组所负责项目（一个Rust编写的VMM）的大部分代码，这让我很快对这个项目的设计与架构有了大致的了解，也让我更加熟练地掌握了Rust语言。同时，这些工作也让我意外地获得了整个BU的第一届代码贡献奖。</p><div align=center>代码贡献奖现场</div><p><img data-src="/images/posts/year_summary_2021/2021-13.jpg"></p><p>去年有关技术上的成长大概可以归纳为以下几个方面：</p><ul><li>入门虚拟化：从只会使用VmWare，到现在开始认真了解虚拟化的原理，阅读KVM源码，并实现了一些VMM的代码</li><li>开始学习Linux内核：阅读了一些和虚拟化以及业务相关子模块的部分源码，同时也编写了几个简单的内核模块。特别是在下半年，由于零零散散地参了一些创新项目，所以也开始对Linux运行所依赖的Arch，以及UML有了更多的理解与思考</li><li>了解容器生态：当前主要局限于单台节点中，比如runc/kata的实现原理，containerd的工作流程等等</li></ul><p>在公司里，技术和业务一直都是牢不可分的，所以，我也借着开发这些代码的由头，了解到了当前云原生的发展形势、当前遇到的问题，以及众多业务场景（比如函数计算和弹性容器）。随着这些背景知识的输入，让我对整个云计算行业，特别是云原生业务的发展前景，抱有较为乐观的预期。</p><p>此外，还有一个好消息是我们大团队将我们平时所研发的操作系统分支及其上下游组件开源为<a href="https://openanolis.cn/">“龙蜥社区”</a>，而我们小团队所做的项目也会通过<a href="https://github.com/openanolis/">龙蜥社区</a>和<a href="https://github.com/kata-containers/">KataContainers</a>这两个社区将源代码贡献出去。所以，后续应该就会有更多可聊的技术相关的东西了。</p><div align=center>云栖大会中和“小龙人”的合影</div><p><img data-src="/images/posts/year_summary_2021/2021-14.png"></p><h1 id="经验-amp-思考"><a href="#经验-amp-思考" class="headerlink" title="经验 &amp; 思考"></a>经验 &amp; 思考</h1><p>经过去年一年的经历，也获得了一些的简单的经验，在这里也将其中一些分享出来。还有一些思考不成体系，略显混乱，就不买弄了，等以后有机会仔细整理，再发出来。</p><h2 id="人的精力有限"><a href="#人的精力有限" class="headerlink" title="人的精力有限"></a>人的精力有限</h2><p>可能因为之前比较年轻，所以总觉得无论有多少事情，我总能想办法做完，大不了熬上几个通宵。</p><p>但是到了现在，发现自己的精力已经远不如本科时候了，如果晚上熬夜，第二天可能就完全无法正常工作，这样效率可能比晚上好好休息还要低。这才让我真的意识到自己的精力有限，很多看起来很有兴趣，动动手就能做完的事情，其实自己并没有精力去做。</p><p>这对于我这样的完美主义者是一个非常大的打击。无限把事情做到完美的代价要么是很多更重要的事情无法完成，要么是自己的健康受到损害，而且甚至牺牲了这两者还是无法把你最想做的事情做到最好。</p><p>在痛苦地挣扎了一段时间后，我还是向规律妥协了：把做事的目的逐渐由把事情做完美变成了把事情做成。我发现影响一件事情成败的关键点只有几个，剩下都是锦上添花，因此做事情不能贪多，需要将它们的优先级进行排序，先做优先级高的，再做优先级低的，虽然有些优先级低的事情做完会让整体更加完美，但是你如果没有精力顾及这么多，那也只能放弃。</p><p>另外，虽然个人的精力有限，但是人多力量大呀。如果能把多个人的力量集合起来，就能完成超出个人能力的更大的事情。不过如何利用别人的力量一起完成一件事情，我暂时还没有特别成功的经验可以分享。</p><h2 id="小事快速决策"><a href="#小事快速决策" class="headerlink" title="小事快速决策"></a>小事快速决策</h2><p>一定有很多人像我一样，是比较纠结的性格，做决策时总是考虑再三，一直无法得到一个明确的结论。这在一般时候不会表现出什么问题，但如果面临的决策非常多，那么做决策这件事儿将会是时间地狱和精力黑洞。</p><p>举一个在工作中常见的例子：在开发一个模块的时候，虽然架构设计已经确定了，但在真正编码的时候依旧经常会面临怎么写比较好这个问题，比如大到一个消息通知机制应该怎么设计，小到这个变量应该叫什么名字。不知道大家会怎么样，我经常会为了这些事情纠结很久，甚至把每种方案都写一遍，看看哪个更好。但最终往往只有两种情况：要么是它不重要，怎么写都可以，要么是只有其中一个设计比较好，但是需要写完后面的代码你才会知道，现在纠结并没有什么作用，甚至可能纠结很久，还是会选择一条错误的道路。</p><p>因此，在当前决策对未来事情发展影响比较小的情况下，快速决策快速做选择快速试错才是比较优的策略，如果一味纠结，不仅会浪费很多时间，而且往往也不会增大把事情做对的概率。所以，纠结症患者不如放下心中的纠结，闷着头随便选一个，省时还省力。</p><p>不过上面的方法并不适用于重要事情的决策。因为重要事情决策可能会对后面产生重大影响，哪怕成功率只提高一点，也会有很大的价值。而决策的关键的是收集和整理信息，如果只顾着快，而忽略了很多有用的信息或没挖掘到信息中比较重要的点，导致决策出现失误，这就得不偿失了。</p><h2 id="合理预估时间"><a href="#合理预估时间" class="headerlink" title="合理预估时间"></a>合理预估时间</h2><p>在多人协作时，每个人的工作可能多少都会依赖别人的工作，而为了便于将每个人的工作进行组合，管理者一般会采用排期的形式把控项目的进度。所以，在工作中，就总会有人问你：你觉得这个事情多久能够完成？</p><p>但从个人的角度来看，面对一个稍微复杂一些的事情：</p><ul><li>总是需要较长的时间完成</li><li>往往中间会因为吃饭/睡觉/开会/有其他更紧急事情等多种原因被分割成多段，保存/恢复工作状态需要消耗意志力和时间</li><li>事情完成的过程中几乎必然会出现许多意料之外的情况</li><li>因为事情紧急，为了督促自己尽快完成，可能会预估一个比较早的时间</li><li>人们的思考模式也决定了我们往往对一个事情的预估是偏乐观的</li></ul><p> 所以，这最终会导致个人对一件事情完成时间的预估是比较乐观的，在deadline之前一段时间往往会拼命去赶，就这样还不一定可以做完，导致延期，而且还可能会由于个人的延期导致项目节奏被打乱，从而导致项目的延期。</p><p> 虽说项目规划者有责任考虑到这些原因，但作为参与人，也有必要对项目完成的时间进行较为合理的评估。目前，就个人经验看来，一件事情完成的时间往往是自己脑中认为可以完成的时间再增加50%以上。因此，在需要精确项目时间的时候，我们可以通过将预估完成时间直接*2的方法来为自己保留合理的裕度。</p><h1 id="新年OKR"><a href="#新年OKR" class="headerlink" title="新年OKR"></a>新年OKR</h1><p>去年，直接用几条flag表达了对新的一年的期望，由于没有合理的checkpoint与拆分，导致很多都没有完成，今年我认为需要改变策略，用用新的OKR工具做做试验，看看是否能让自己真正动起来，将目标的完成率提高。</p><p>下面，就将今年的一些OKR列出来，不过使用博客跟踪OKR的效率肯定不高，所以后续会尝试配合一些跟踪目标的软件一起使用。</p><h2 id="Object1：生活健康自律"><a href="#Object1：生活健康自律" class="headerlink" title="Object1：生活健康自律"></a>Object1：生活健康自律</h2><p>健康的身体是一切的前提，所以我希望将身体健康，生活自律放在OKR的第一位</p><h3 id="KR1-早睡觉，不熬夜"><a href="#KR1-早睡觉，不熬夜" class="headerlink" title="KR1: 早睡觉，不熬夜"></a>KR1: 早睡觉，不熬夜</h3><p>睡眠质量对身体健康和工作效率都十分关键，因此早睡早起是必须要做到的目标。</p><p>由于之前都睡得比较晚，睡眠时间需要慢慢调整，所以将晚睡定义为在凌晨12:40之后上床睡觉</p><p>非特殊情况，每周最多有一天晚睡/熬夜</p><h3 id="KR2：坚持锻炼"><a href="#KR2：坚持锻炼" class="headerlink" title="KR2：坚持锻炼"></a>KR2：坚持锻炼</h3><p>由于每天的工作都是对着电脑久坐，因此必须要让自己有时间动起来</p><p>锻炼以一定强度的有氧运动为主，且不能过于剧烈，可选的方案：慢跑、球类运动、骑行、爬山、跳绳等，时长以30分钟以上为宜</p><p>在三月份气温回暖后，非特殊情况（如生病/出门在外等）每周至少进行三次锻炼活动，三月份之前，每周至少两次</p><h3 id="KR3：健康饮食、控制体重"><a href="#KR3：健康饮食、控制体重" class="headerlink" title="KR3：健康饮食、控制体重"></a>KR3：健康饮食、控制体重</h3><p>饮食对身体健康的影响也十分显著，体重亦是如此，因此需要进行合理的安排</p><p>饮食目前没找到太好的定量约束方案，就限定一下吃饭速度吧，如果有一同吃饭的人，不能吃的比所有人都快</p><p>体重比较方便定量，在3月份气温回暖后，逐渐将体重控制在70KG（±3KG）</p><h2 id="Object2：知识的输入和输出"><a href="#Object2：知识的输入和输出" class="headerlink" title="Object2：知识的输入和输出"></a>Object2：知识的输入和输出</h2><h3 id="KR1：阅读原版书籍"><a href="#KR1：阅读原版书籍" class="headerlink" title="KR1：阅读原版书籍"></a>KR1：阅读原版书籍</h3><p>只有阅读一手知识才能让自己真正理解知识，通过看视频/读别人的笔记获得知识的速度虽然快，但是可能会忽略掉其中的许多细节</p><p>能增长知识的书籍分为两种：技术书籍和人文社科书籍，它们的阅读方式和收获也是不同的，因此单独制定计划：</p><p>技术书籍两本：</p><ul><li>计算机体系结构——量化研究方法</li><li>暂定</li></ul><p>人文社科书籍五本：</p><ul><li>八次危机</li><li>暂定</li></ul><p>另外，暂定每周有五天时间每天阅读半小时</p><h3 id="KR2：学习优秀源码"><a href="#KR2：学习优秀源码" class="headerlink" title="KR2：学习优秀源码"></a>KR2：学习优秀源码</h3><p>精读优秀的源代码和原版书籍一样重要，需要仔细阅读，暂定两个虚拟化的项目，后面再做补充</p><ul><li>KVM</li><li>QEMU</li></ul><h1 id="KR3：输出内容"><a href="#KR3：输出内容" class="headerlink" title="KR3：输出内容"></a>KR3：输出内容</h1><p>在阅读完别人的内容或者自己进行一些实践活动之后，如果不及时总结，可能会导致没有彻底理解，而总结的最好方式就是输出一篇较长的文章，既锻炼逻辑思维，也提升写作能力，因此暂定一年输出五篇文章</p><h2 id="Object3：其他目标"><a href="#Object3：其他目标" class="headerlink" title="Object3：其他目标"></a>Object3：其他目标</h2><p>除了主要方向外，还有一些其他的目标，暂时只列陪伴家人，后续再做补充</p><h3 id="KR1：陪伴家人"><a href="#KR1：陪伴家人" class="headerlink" title="KR1：陪伴家人"></a>KR1：陪伴家人</h3><p>陪伴家人的目标去年执行得不错，今年要继续保持</p><ul><li>每周和家人电话</li><li>逢年过节没有疫情的情况下回家</li></ul><h1 id="The-End"><a href="#The-End" class="headerlink" title="The End"></a>The End</h1><p>最后，就以前几天自己做的一个梦作为博客的结尾吧：不知何年何月何日，乘坐一架很大的宽体客机回家，但是飞到大约三分之二的地方，飞机突然失控坠向地面，好在紧急迫降成功，降落在了一个不知名的地方。这里到处都是荒漠，还有一些居民，只有天边模模糊糊可以看见草原。手机导航没有坏，它告诉我没有别的交通方式，只有步行导航，而且需要走很久很久才能到家。我也找了一圈，也的确没有看见其他的交通工具。许多乘客都因要很久才能到目的地而选择在这个荒漠小城留下，看情况再决定是否出发，但是我在找附近的居民买了一些馕作为干粮后，马上就出发了。</p><p>能不能走出荒漠，我不知道，至于能不能走回家，就更不知道了。但是梦中的我做出了坚决的选择：不要在意这些，走下去，马上出发！</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;intro&quot;&gt;&lt;a href=&quot;#intro&quot; class=&quot;headerlink&quot; title=&quot;intro&quot;&gt;&lt;/a&gt;intro&lt;/h1&gt;&lt;p&gt;在抬笔之前，纠结许久，过去的这一年，真的有这么多要记录的东西么，有必要花几个小时的时间去写么？我不知道。但同时，我的鼠标已点开了之前的博客，开始翻看前些年写的文字。看着看着，我找到了许多自己已经不怎么记得，但想起却感到十分温暖的那些瞬间和回忆。虽说都不是什么大事儿，但是如果不记录，它们可能真的就会遗失在记忆的荒野里了。&lt;/p&gt;
&lt;p&gt;所以，我还是要写些文字，来记录我这平凡，也小有起伏的一年时间。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://blog.zhengi.me/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="年终总结" scheme="https://blog.zhengi.me/categories/%E9%9A%8F%E7%AC%94/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="年终总结" scheme="https://blog.zhengi.me/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>追寻良质——禅与摩托车维修艺术</title>
    <link href="https://blog.zhengi.me/notes_on_zen_and_the_art_of_motorcycle_maintenance/"/>
    <id>https://blog.zhengi.me/notes_on_zen_and_the_art_of_motorcycle_maintenance/</id>
    <published>2021-07-24T17:24:13.000Z</published>
    <updated>2024-03-23T06:03:16.943Z</updated>
    
    <content type="html"><![CDATA[<p>在挺久之前，可能是刚读大学的时候，就隐约听说这本《禅与摩托车维修艺术》的大名，也得到了几位朋友推荐，但在当时，翻过几页后发现根本看不下去，就束之高阁了。这次终于在好奇心的不断怂恿之下花费了一些意志力重新拾起，终于随着情节的展开，同作者一起踏上了骑着摩托车横穿整个美国的长途旅行。</p><p>在最开始的认知中，我认为这场摩托车旅行一定是一个非常酷的故事，但后面发现虽然故事的确很酷，却非第一印象中的那种酷。</p><p>在这场旅行中，我在了解美国地理的同时，也被作者和“斐德洛”的暗中较量所吸引，对父亲与克里斯的矛盾所疑惑，更为寻找“良质”同作者（或者说是“斐德洛”）一起陷入了对当下的反思。</p><span id="more"></span><h1 id="故事"><a href="#故事" class="headerlink" title="故事"></a>故事</h1><p>先大概说说这个故事吧。本书讲述了作者与儿子（还有友人）骑着摩托车进行了横穿美国的长途旅行，在旅途中，他骑着摩托车通过多次“肖陶扩”(Chautauqua，看起来是一种露营+讲学的结合体，在上个世纪的美国比较流行)对过去的自己的思想与经历进行了回忆和反思，最终也与过去的自己及儿子和解的故事。</p><p>随着故事的深入，读者会发现作者的大脑中存在着两个人，一个是当下的他，即波西格，另一个是过去的他，即斐德洛。这都是由于斐德洛由于对“良质（Quality）”的狂热探求，导致他的精神出现问题，而后他接受了电击治疗，导致他的思维、记忆和性格产生了变化，变化后的人就是现在的他。</p><p>这是作者在故事结构上非常巧妙的安排之一，一开始读者读起来总觉得作者说的某些话语很奇怪，隐隐觉得哪里不对劲，有时候甚至会感到后背发凉。直到后面才知道那些话其实是“斐德洛”借作者之口说出来的，这才恍然大悟，并在不知不觉中接受了这个设定，为后面对斐德洛思想的探寻做足了铺垫。</p><p>另一个比较有意思的地方是“虚实结合”（不确定这个词用在这里是否准确）。在书中，作者对“禅”的思考和摩托车旅行是相互交织展开的。在对骑行的描写中可能随时会开始“肖陶扩”，转向对思想的讨论，而在讨论进行的过程中也可能会切换回对旅行的而描述。这样的切换在写作的时如果把握不好就会显得十分生硬，但是作者的处理还是相当到位的——旅行中的种种波折与斐德洛在思想上的进步与挫折以及作者和儿子的关系都在相互映照，它们的节奏也都完美契合。</p><p>不过，也不是所有的情节都是完全契合，而是在契合中又有升华。比如在第三部分的作者选择了和当年不同的路，致使他没有再次“发疯”。故事大概是作者从“斐德洛”的老朋友狄威斯家中出来以后，准备攀爬一座雪山，这座山不是一座普通的沿途小山，而是一座需要数天才能攀爬上去的山，而且还是斐德洛当年在思考良质的过程中会经常去爬的山。因此，这座山其实也不仅是现实中的一座山，其更是一个隐喻，隐含着斐德洛对良质的艰苦探索的过程。</p><p>而这次，他和儿子在进行持续几天的艰苦跋涉逐渐接近山顶的时候，因为他担心在山顶会产生”雪崩“，就选择不再登顶了。可以看出，雪崩在这里其实也是一个隐喻，这象征着一旦到了山的顶点，即找到所谓”良质“后，就会遇到雪崩，即作者思想上的崩溃。而这次作者选择不完全爬上山顶，就避免了再次雪崩的情况，只是在崩溃的边缘而没有完全失控。而最后，儿子或者说亲情“解救”了他（或者说是斐德洛），让他的神智重新回归了正常。</p><h1 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h1><p>作者的思考由旅行同伴约翰夫妇对学习摩托车维修的抗拒开始。他认为约翰夫妇由于从事的是艺术工作，所以害怕（或是说不喜欢）现代科技所使用的分析方法，因此主动屏蔽对机械运行原理的学习与思考，而只是将它们当作一个整体来考虑。</p><p>作者从这里引出了“古典的”和“浪漫的”这一对立认知形式。他认为古典的认知就是像现代科学这样，凭借理性对某一事物不断细分，以求认识其中的规律；而浪漫的则是凭借直觉与灵感，对事物进行把握。而当代这两种认知方式之间的分歧越来越严重，达到了难以对话的程度。正如他与约翰夫妇之间的分歧那样。</p><p>可以看出，作者很难找到一个合适的形容词对这两种思想进行表达，所以使用两个在我们语境里看起来不那么准确的词语进行描述。我认为古典的意思就是现代的理性主义，强调将事物划分为理性中不同的领域和范畴，并对范畴进行不断地细分，以求掌握事物运行规律的认知形式。而浪漫的则指一种综合地认知事物地方式，强调事物间的共性与联系，但往往由于世界的复杂性，无法用科学原理进行证明或证伪，所以有可能被认为是某种超越科学的“神秘主义”。而我之所以认为在我们语境里这两个描述不够准确，是因为“古典的”在西方世界里就是理性的化身，而我们则恰恰相反。</p><p>接着，作者对科学进行了反思，他认为科学也是某种潜藏在我们大脑中的“鬼魂”，相信科学的我们并不比相信宗教的古人更加智慧。这之后的作者便踏上了对“斐德洛”思想的回顾历程，因此后文的“他”一般均指斐德洛。</p><p>他在进行科学研究的过程中发现科学家（他自己当时就是在做化学相关的研究）总是在大胆假设和小心求证中不断前行，但是“大胆假设”环节看起来不太符合理性的逻辑，因为假设会随着科学范畴的增多爆炸式增长，这样就会导致我们会越来越无法从众多假设中找到符合逻辑的结论。</p><p>这其实正是现代科学所需要面对的一个很大的问题，更底层地看，这需要我们对自己的认知世界的方式，也就是经验主义进行反思。而作者的反思是通过休谟与康德的对话进行的。休谟曾经对人类的认知模式提出了三个问题：因果问题、归纳问题、应然与实然的问题，这三个问题直指经验主义，如果无法解答它们，那么我们建立在经验上的科学将没有任何价值。康德拯救了经验主义（并向我们抛出了三大批判），他通过引入“先验”这一概念，确认了只有经验是不够的，还需要我们认知世界的思考范式。虽然康德的思想惊艳到了斐德洛，但是斐德洛认为康德的《判断力批判》中对美学的理性解释却非常丑陋。</p><p>可以看到，作者在这里对科学的理性和感性对立的认知已经从当初的经验阶段（科学的危机）走向了理论阶段（认识论），他已经开始摆脱实践，转而走向了纯粹形而上的追寻。事实上，他也从最开始就读的大学退学，转而去韩国当兵，而后去印度修习“东方哲学”。</p><p>而后，他开始在蒙大拿州立大学教授修辞学。他希望他所在的大学是实质上的大学，而非形式上的大学，即空有大学的建筑，而没有大学的思想，他的脑中逐渐构建了一个理想中的“理性教堂”。他在那时，又开始了在课堂中的实践，但是发现了理性在修辞学上的矛盾之处——无法使用理性对修辞学进行归纳和总结，最后形成规律，因为作者在写出伟大作品的时候，并不会在脑中实现想好自己要用什么修辞，好的作品都是靠着灵感这种非理性的东西所完成的，那么他教授学生通过理性归纳得到的这些规律又有什么意义呢？所得到的都只是一堆拙劣的模仿。</p><p>而这其中，为了完成一部好的作品中，究竟是什么在起作用呢？就是“良质（Quality）”。他知道良质这个东西是真实存在的，写出好的作品、辨认好的作品都需要依靠良质，但良质却又不依靠理性存在。从这里开始，他踏上了找寻良质的一条“不归路”，从这里起，现在的作者和儿子也开始攀登雪山，全书逐渐迈向高潮。</p><p>一开始，他的一个重大发现是良质根本无法被定义，因为一旦被定义，或者说是被范畴所规定，良质就不再是良质了。所以他在读到《道德经》中“道可道，非常道”这句话时，才觉得遇见了知音，良质和“道”居然是一个东西。不仅如此，他认为良质和美学、佛学以及神学其实都是一个东西。宗教的、东方的与艺术的，这些无法被理性哲学所把握的（或者是被作者所鄙视的”范畴学家“所毁坏的）事物，在良质这里得到了统一。</p><p>可以看到，作者终于从西方的理性思维和二元论中跳脱出来开始意识到许多无法被理性所把握的事物的存在，但是很快我们将看到由于他所在的社会环境以及他的历史局限性，他还是无法摆脱被二元论分割以及被范畴所规定的命运。同时也可以看到作者希望对思想世界进行统一的野心。</p><p>现在的作者不仅阅读了斐德洛的手稿，还更广泛地阅读了其他人的作品，发现了许多类似的思潮，他们都希望能从不同的侧面爬上这座山峰（但殊不知老子已经在数千年前在山顶俯视他们了）。比如著名数学家和哲学家庞加莱，他意识到科学，包括数学只是一种解释世界的工具。我们能通过理性推到出无数可能的世界，但是无论它们在理性上有多么完美，但是最终被应用的一定是能更好解释现实世界的现象的学说。那如何从成千上万的理论中挑选出合适的理论呢？庞加莱认为这个是灵感，或者说是潜意识，但由于纠结于主体与客体分离的二元论中，他没有得到具体的答案，而作者认为答案就是”良质“。</p><p>接下来，作者探讨了良质的应用，特别是在解决某些问题（如修理摩托车时）被卡住的时候，良质会帮你度过难关。他提出了一个很有意思的比喻，古典的认知方式是火车的引擎，可以让火车开动，但是浪漫的认知方式（即良质）却像铁轨那样指引了火车前行的方向。</p><p>后面，他又对康德发起了挑战，认为人在意识到事物之前的那一刹那，产生作用的其实就是良质，这时候良质是一个一元论的概念，主客体是一体的。为什么他认为科技是丑陋的？因为科技是被严重二元化的，是被分析的，没有良质的存在。同时他也总结了能将良质应用于工作中的方法，即让内心进入真正的平静，从而获取进取心。</p><p>读到这里，看起来作者已经找到了良质的关键之所在，已经即将登顶那座雪山，但是情况却急转直下。因为他希望继续对良质进行深入研究，于是他希望去芝加哥大学的一个叫“观念分析与方法研究”的交叉学科就读博士学位，继续对良质进行探究。然而他去了之后，遇到的阻力不再是近代的休谟康德黑格尔，而是西方理性思维的源头——苏格拉底、柏拉图和亚里士多德。他与委员会，即这几位思想家在现代的化身，特别是亚里士多德的交锋才刚刚开始。他为了保护他的发现——良质，开始变得狼性，时刻准备与委员会进行战斗。但最后他的心智失去了平衡，走向了疯狂。</p><p>（为什么我这里没有介绍他们之间你来我往的交战过程呢？是因为我学艺不精，对古希腊哲学知之甚少，无法支撑我进行有效的总结。希望之后有机会补充吧。）</p><p>最后，现在的作者在儿子的牵引下，没有重蹈之前的覆辙，走向了一个完全不同的结局。</p><h1 id="什么是良质"><a href="#什么是良质" class="headerlink" title="什么是良质"></a>什么是良质</h1><p>我相信所有读完这本书的人（包括我自己），在合上书之后，还是会不断思考这个问题：“良质”究竟是什么。</p><p>接下来是我个人的理解：</p><p>但凡问出这个问题，就意味着已经自己的思想已经被理性主义的幽灵所掌控，因为理性主义总是希望将事物归为一个范畴，然后进行分析总结，最终把握这个事物。</p><p>但是理性走到这里，却只能碰壁了，因为“良质”无法被范畴所规定。这里再次化用《道德经》开头的这段话：“道可道，非常道；名可名，非常名。无名天地之始，有名万物之母。”大概意思是，道只要被名说出来，那就不是原来的道了。那道德经怎么来解释这个道呢？就只能通篇说道不是什么，通过不是来表现出其是什么。所以我们也只能说出“良质”不是什么，而无法说出其是什么。</p><p>那么良质不是什么呢？这里的答案就很明确了，那就是能被范畴所规定的各类事物，也就是理性。</p><p>我觉得还需要对范畴还想多说两句，它只是我们大脑中对事物强加的一种观念，便于对这个事物进行把握。但是，这只是大脑的思维模式，并不是真实的物质世界，物质世界给我们大脑所传递的，只有一堆混沌的信号罢了，我们是通过某种观念（可能是先天的，也可能是经验）对信号进行处理，从而形成认知。而至于为什么会是现在这样，那就是另一个话题了，需要从语言与存在中找寻答案。</p><p>说完上面这些，可能还是不能完全让人明白什么是”良质“。但是如果此时还没有明白，我也没办法，只能寄希望于某一刻产生的思想火花了。其实并不只有我，古代的先贤们也没办法。因此，他们管这件事情叫“悟道”或者叫“开悟”，而佛学还有一个专门形容一个人开悟难度和可以开悟程度的词，就是“慧根”。</p><h1 id="几点思考"><a href="#几点思考" class="headerlink" title="几点思考"></a>几点思考</h1><p>首先，我想试着简单分析一下我所认为的作者精神崩溃的原因。</p><p>从书中的描写可以了解到，作者在最开始是一个纯正的理性信徒，但通过发现的数个矛盾，悟到了”良质“，发现了一个更广阔的非理性（也可以称之为感性）世界的存在。而后，他开始向理性世界的中心，即古希腊三杰在现代社会的代理人主动发出挑战，并在挑战的过程中精神崩溃。</p><p>可以看出，他前期的艰苦探索都是非常积极的，甚至在打破二元世界，接受一元论与感性世界的时候，都没有表现出太多的痛苦。但是在挑战理性权威的过程中，他开始变得好斗，并且把学术上的争论上升到了个人的层面，甚至有了一些被迫害妄想症的味道，这导致他最后吞下了苦果。</p><p>但是，他真的完全接受一元论，或者说是活在一元论中了么？我看未必。委员会最开始见到斐德洛的时候，希望使用范畴把他的研究，即良质进行规范。如果是我，我会认为已经跟你说了这么多，你这个人却还没有开悟，没法交流，直接扬长而去便可。但是他却留下来，在逻辑与范畴中开始斗争。这是一个非常不明智的决定，也是注定不会成功的斗争。这可能是由于他希望统一思想世界的野心，也可能是因为他作为一个出生开始就接受二元论教育的人，对一元论还无法向我们这样融汇贯通。</p><p>以上是他个人的局限性，当然还有历史的局限性。作者接受教育的时候，存在主义应该在美国还没有大面积流行起来，而共产主义在美国更是一种禁忌，这导致存在主义的两大先驱任务——马克思和海德格尔的思想和著作，完全没有进入作者的视野，如果他早些读到这些著作，可能会对良质拥有更加深刻地认识了。同样地，他也不会发起那场同古希腊先贤们地那场毫无意义地争斗，因为已经有人帮他做过了。他要做的，可能会是把这套理论进行实践，无论是在他擅长的修辞学上，还是在艺术上，甚至是像马克思那样在社会革命上。</p><p>另外，在读完以后，还看了知乎上对本书的一些讨论，和此书高达8.6的豆瓣评分和创记录的销量完全不同，几乎都是负面的评论，这让我很意外。看下来许多人几乎都觉得这本书完全不值得读，觉得是“机场文学”，里面讨论的哲学都是所谓“民科”级别的，如是云云。</p><p>我承认知乎上可能会有许多通晓哲学思想的大师，但是这本书对于一般读者而言，其难度其实并不低，甚至可能会有很多人会像当年的我那样，因为完全没有基础知识导致根本看不下去。读书也是“小马过河”，不能用自己的标准衡量别人。</p><p>哲学这门学科在希腊语中的本来的翻译是“爱智慧”，它不像科学那样有固定的范畴与研究方式。就像作者对“良质”的探索那样，虽然早有人从一条路抵达了山顶，但还是需要有更多的人从更多的路探索更多的山顶，虽然他们大部分人都停留在了山底或者是半山腰，但是这些探索不论是对个人还是对社会来说都是有意义的。绝不能当作者在芝加哥遇到的“委员会”中的那类人。</p><p>最后，回到本书最开始作者对科技的思考。作者认为他那个时代的科技产品都遵循“古典式”的思考方式，没有“浪漫式”的思考，这导致很多人不喜欢科技产品，更不愿意了解其原理。而在现在这个时代，我认为事情已经悄然发生了很大的转变。首先，我想到的就是乔布斯对科技与人文十字路口的论断，他用苹果的产品证明了科技与人文是可以相互融合的。另外，我也也看见身边越来越多的人成为了”全栈开发人员“，他们不仅对技术了如指掌，更对用户交互设计了然于心。最后，昨天夜间还看见了何同学的毕业视频，这不也正是这种精神的完美阐释么？不知波西格在成书多年以后，看见如此这般的当下，会有何感想。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在挺久之前，可能是刚读大学的时候，就隐约听说这本《禅与摩托车维修艺术》的大名，也得到了几位朋友推荐，但在当时，翻过几页后发现根本看不下去，就束之高阁了。这次终于在好奇心的不断怂恿之下花费了一些意志力重新拾起，终于随着情节的展开，同作者一起踏上了骑着摩托车横穿整个美国的长途旅行。&lt;/p&gt;
&lt;p&gt;在最开始的认知中，我认为这场摩托车旅行一定是一个非常酷的故事，但后面发现虽然故事的确很酷，却非第一印象中的那种酷。&lt;/p&gt;
&lt;p&gt;在这场旅行中，我在了解美国地理的同时，也被作者和“斐德洛”的暗中较量所吸引，对父亲与克里斯的矛盾所疑惑，更为寻找“良质”同作者（或者说是“斐德洛”）一起陷入了对当下的反思。&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="https://blog.zhengi.me/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="https://blog.zhengi.me/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="禅与摩托车维修艺术" scheme="https://blog.zhengi.me/tags/%E7%A6%85%E4%B8%8E%E6%91%A9%E6%89%98%E8%BD%A6%E7%BB%B4%E4%BF%AE%E8%89%BA%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>2020年终总结</title>
    <link href="https://blog.zhengi.me/year_summary_2020/"/>
    <id>https://blog.zhengi.me/year_summary_2020/</id>
    <published>2021-01-01T09:09:34.000Z</published>
    <updated>2024-03-23T06:03:16.947Z</updated>
    
    <content type="html"><![CDATA[<p>时间很快，如今已经是2021年伊始了。虽然已经很久没有写过文章，但是，面对2020年，我总还纠结着要说些什么。</p><p>2020最大的主题就是变化。不仅有意料之中的变化，更多是意料之外的变化。</p><h1 id="疫情"><a href="#疫情" class="headerlink" title="疫情"></a>疫情</h1><p>说到变化，总也绕不过的就是疫情。</p><p>我的2020年是以一次滑雪作为开始，在那场滑雪之后，我还在畅想在结束毕业论文写作之后，毕业前的时间我应该怎样度过，是要趁着有闲逛上大半个中国，还是省一些钱躲在实验室里啃啃买来一直没读的大黑书。</p><span id="more"></span><div align=center>年初滑雪</div><p><img data-src="/images/posts/year_summary_2020/2021-01-02-11-11-18.png"></p><p>放假回家后，就开始盘算：工作后肯定没法在家待太长时间，不妨这次放假在家里多待几天，多陪陪家人（多睡睡懒觉），不到交论文的那天，坚决不回学校。</p><p>然而现实远超我的想象，不仅交论文的那天没能回学校，甚至到了毕业那天，都不能回去。</p><p>事情的起因还是一月份开始听说有一种类似SARS的病毒已经开始悄然传播，那时候感觉病毒还很远，和我没有关系；直到除夕前一天，武汉封城，全国人民在家过年，我开始知道它的名字叫新冠病毒，而且十分严重，和我们每个人每天的生活息息相关；后面，我又通过躲在手机屏幕后的暗暗观察，发现这件事情不仅改变了我的计划，改变了中国人的生活，甚至整个人类都与此息息相关；而直到一年后的今天，疫情依旧不知疲倦地在全球蔓延。</p><p>是呀，仿佛离我们很遥远的事情，在短短一年内变成了每个人所面临的现实，这对于一直沿着一条可被经验预测的道路前行的我来说，的确是一种震撼。</p><p>另外还有一个比较深刻的感受，是“正常化偏误”。之前听的比较多的一个例子是一个小镇旁边有一座火山，那里的居民居然在火山爆发以后觉得问题不会那么严重，没有逃跑，导致伤亡惨重。我想我一定不会这么蠢，一定要最开始就逃走。但是，当疫情来临的时候，我在最开始就觉得应该是要买口罩了吧？但是又觉得会不会没这么糟，现在就去买口罩会不会显得自己很异类？就这样拖延了两天，发现城里已经几乎买不到正常价格的口罩了。过后，我才醒悟过来，原来自己也随时可能变成眼看着火山灰把自己掩埋的那个人，这也是我2020年学到的第一个教训：当你觉得应该行动的时候，就一定要开始行动，不要在乎别人眼里你是怎样的。</p><h1 id="病情"><a href="#病情" class="headerlink" title="病情"></a>病情</h1><p>在疫情不太紧急的四月份，在家赋闲，于是给自己送给一台手术作为生日礼物。人生第一次手术还挺成功，我的胆囊和矿泉水瓶盖大的结石永远地离我而去。不多说，希望看到这里的每一个人都能按时吃早饭，健康饮食吧。</p><h1 id="毕业"><a href="#毕业" class="headerlink" title="毕业"></a>毕业</h1><p>在开始读研的时候，我预想了无数种毕业时候我会做些什么，至少应该和卤蛋同学补上之前本科毕业没拍成的毕业照。但万万没想，这次毕业没有聚餐，没有毕业照，甚至都没有亲手拿到打印出的沉甸甸的论文，只有腾讯会议上大家还算灿烂的笑容（毕竟所有同学都顺利毕业）。</p><div align=center>毕业“合影”</div><p><img data-src="/images/posts/year_summary_2020/2021-01-02-11-17-03.png"></p><p>毕业以后我的一个愿望是等疫情结束，能回到陪伴我三年时间的小灰楼302去逛逛，找潘老师以及师弟师妹们聊聊天，可惜变化永远都是猝不及防——当时老纪说的多年前位于澡堂三层的上古实验室居然变成了我们如今的新去处。</p><h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>人呐就是不知道，自己就不可预料。我绝对不知道，我作为一个搞网络搞SDN的，怎么就来做云原生了。</p><p>说实话，福厂的工作节奏还是有点快，让摸了七年鱼的我花了很久去适应了。不过好在我遇到了一群非常nice的同事，特别是几位师兄，从他们那里学习到了非常密集的知识，让我从一个无法无天的野生程序猿变成了一个（自认为）还算及格的底层工程师。</p><p>这半年来，我的工作主要集中在和容器沙箱相关的技术之中，从一个虚拟化的门外汉，到看见了门槛之所在。另外，通过熟读Firecracker源码，也让我对Rust和microVM有了一个全新的认识。</p><div align=center>在公司遥看望京SOHO</div><p><img data-src="/images/posts/year_summary_2020/2021-01-02-11-17-27.png"></p><h1 id="读书or视频"><a href="#读书or视频" class="headerlink" title="读书or视频"></a>读书or视频</h1><p>今年唯一的遗憾就是没有阅读太多的书，特别是很多书读到一半就放下，并没有读完。分析是两个方面的原因：一是由于生活模式的切换，自由时间变少，时间碎片化严重，没有相对较长的时间和精力来进行阅读；另一方面是B站使用时间显著增长，妄图通过对知识区视频的学习跳过读书快速获取知识。</p><p>这里可以借这个机会稍微聊聊我对B站的体会：在深度使用B站接近1年后，就知识区和科技区来看，UP主的数目持续增多，优质稿件也不断变多，这就吸引我每天花费大把的精力在观看所关注UP主的视频上，甚至都不敢去刷推荐流，很担心又看上哪个新的up主，想去追视频但是已经没有时间了。我不知道这是好事还是坏事，但是对B站来说绝对是一件好事，每天都会冒出许多新的创作者，分享许多奇奇怪怪的新内容，而且这也的确能够吸引观看者花费更多注意力在B站上面。这一切的一切，让我想起了刚上大学时候的微信公众号，嗯，熟悉的感觉又回来了。</p><p>还是说回读书，我认为能够进行较长时间专注的阅读，特别是大部头的书，对我来说还是十分重要的。因为视频中的知识点往往都比较零散，而且很难讲深，构成体系，只能作为谈资泛泛去听。所以，我认为系统性地读书还是十分必要的，接下来我一定得压缩每天在B站上花费的时间，重新回来读书中来。</p><p>希望接下来的一段时间，先把剩下的半本《红楼梦》读完。</p><h1 id="一点思考"><a href="#一点思考" class="headerlink" title="一点思考"></a>一点思考</h1><p>论2020年对我影响最大的人，莫过于温铁军和他的《八次危机》了。在B站看见他的视频后，发现他的思想理论和主流观点差别很大，但是又有一种吸引我不断去看他的演讲去思考他说过的每一句话的魅力。原因很简单，我逐渐意识到，他说的可能才是对的。</p><p>回想起来，印象最深的莫过于“代价”和“矛盾”，大到国家发展现代化需要代价，维持现有制度也需要代价，小到个人，过上好日子需要代价，不被别人支配更需要代价。大概就是只要你想要改变现状，就总要付出点你当下拥有的资源，以便让你在未来的时空里拥有你想要的资源。之前中学老师的一句口头禅“出来混，总是要还的”大概就是这个现象的通俗版本吧。和代价孪生的是“矛盾”，因为代价总是需要牺牲一些来成全另一些，那么牺牲者与被牺牲者之间就会产生矛盾，那么我想这也可能也是导致矛盾在不同的时期动态变化的一个原因。正因为代价和矛盾的不断转换，推动了事物的不断发展，个人是这样，国家和世界也都是这样。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>昨天午睡的时候做了一个梦，梦见自己在搬家，搬家的对象中有一个大箱子，很难搬走。箱子里装的是一个游戏，游戏的在一些城堡中发生，城堡的主人既希望继续战斗，赢得更大的城堡，又担心自己进攻的时候自己的城堡被别人抢走。我纠结了很久，决定让主人公继续战斗，并终于搬走了这个箱子。但是做完这个决定后，感受到了无尽的空虚与劳累，就仿佛做了一个多大的选择一样。紧接着，突然惊醒，意识到这个城堡小游戏的经历原来可能是自己前一天晚上没睡好而在纠结是否要起床的投影。可真的就只是这样么？我想也不尽然。总之，既然已经在梦中做出了选择，就不如在2021继续践行吧。</p><h1 id="Flags"><a href="#Flags" class="headerlink" title="Flags"></a>Flags</h1><p>最后是每年的保留节目，立Flag，希望明年都能完成：</p><ul><li>分享至少5篇较为优质的内容</li><li>对领域内技术的认知上有明显提升，具有一定的专业性和深度</li><li>维持学习状态，保持对世界的好奇心，对世界的认知上更进一步</li><li>阅读，至少5本较篇幅较长的著作，减少看视频的时间</li><li>锻炼身体，体重维持在80kg以下</li><li>多陪陪家人，每周和家人通话</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;时间很快，如今已经是2021年伊始了。虽然已经很久没有写过文章，但是，面对2020年，我总还纠结着要说些什么。&lt;/p&gt;
&lt;p&gt;2020最大的主题就是变化。不仅有意料之中的变化，更多是意料之外的变化。&lt;/p&gt;
&lt;h1 id=&quot;疫情&quot;&gt;&lt;a href=&quot;#疫情&quot; class=&quot;headerlink&quot; title=&quot;疫情&quot;&gt;&lt;/a&gt;疫情&lt;/h1&gt;&lt;p&gt;说到变化，总也绕不过的就是疫情。&lt;/p&gt;
&lt;p&gt;我的2020年是以一次滑雪作为开始，在那场滑雪之后，我还在畅想在结束毕业论文写作之后，毕业前的时间我应该怎样度过，是要趁着有闲逛上大半个中国，还是省一些钱躲在实验室里啃啃买来一直没读的大黑书。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://blog.zhengi.me/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="年终总结" scheme="https://blog.zhengi.me/categories/%E9%9A%8F%E7%AC%94/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="年终总结" scheme="https://blog.zhengi.me/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>使用VSCode对Linux内核进行调试</title>
    <link href="https://blog.zhengi.me/debug-linux-kernel-with-vscode/"/>
    <id>https://blog.zhengi.me/debug-linux-kernel-with-vscode/</id>
    <published>2020-05-05T01:56:50.000Z</published>
    <updated>2024-03-23T06:03:16.943Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇博客<a href="/debug-linux-kernel-with-vscode">使用Qemu和GDB对Linux内核进行调试</a>中已经介绍了使用Qemu和GDB对Linux内核进行调试的方法，但是GDB调试对于用惯了GUI工具的人（比如我）来说并不是很直观，所以就希望尝试使用比较熟悉的GUI编辑器，如VSCode，对内核进行调试。</p><p>由于VSCode的调试方式同样基于GDB，所以需要先在GDB中测试没有问题。</p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>需要在VSCode的插件市场中安装微软官方的C/C++插件，该插件可用于IntellSence和GDB调试。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>为了使VSCode支持内核的调试，需要配置launch.json，特备注意需要配置<code>setupCommands</code>属性，以便在GDB启动后对其进行设置，大致的配置文件如下：</p><span id="more"></span><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">    <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">    <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(gdb) linux&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceRoot&#125;/vmlinux&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;miDebuggerServerAddress&quot;</span><span class="punctuation">:</span> <span class="string">&quot;localhost:1234&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;miDebuggerArgs&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-n&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;targetArchitecture&quot;</span><span class="punctuation">:</span> <span class="string">&quot;x64&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;set arch i386:x86-64:intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dir .&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;add-auto-load-safe-path ./&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在添加配置后，直接在VSCode中设置断点，然后启动Qemu，最后在VSCode中启动调试即可。</p><h2 id="其它配置"><a href="#其它配置" class="headerlink" title="其它配置"></a>其它配置</h2><p>如果不仅需要使用VSCode对内核进行调试，还希望进行编辑，特别是激活IntelliSence以及格式化等功能，还需要对VSCode进行进一步的配置，具体配置已经置于GitHub仓库<a href="https://github.com/imaginezz/vscode_config_debug_kernel">https://github.com/imaginezz/vscode_config_debug_kernel</a>中，可以直接Clone为内核文件夹中的<code>.vscode</code>目录。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在上一篇博客&lt;a href=&quot;/debug-linux-kernel-with-vscode&quot;&gt;使用Qemu和GDB对Linux内核进行调试&lt;/a&gt;中已经介绍了使用Qemu和GDB对Linux内核进行调试的方法，但是GDB调试对于用惯了GUI工具的人（比如我）来说并不是很直观，所以就希望尝试使用比较熟悉的GUI编辑器，如VSCode，对内核进行调试。&lt;/p&gt;
&lt;p&gt;由于VSCode的调试方式同样基于GDB，所以需要先在GDB中测试没有问题。&lt;/p&gt;
&lt;h2 id=&quot;插件&quot;&gt;&lt;a href=&quot;#插件&quot; class=&quot;headerlink&quot; title=&quot;插件&quot;&gt;&lt;/a&gt;插件&lt;/h2&gt;&lt;p&gt;需要在VSCode的插件市场中安装微软官方的C/C++插件，该插件可用于IntellSence和GDB调试。&lt;/p&gt;
&lt;h2 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h2&gt;&lt;p&gt;为了使VSCode支持内核的调试，需要配置launch.json，特备注意需要配置&lt;code&gt;setupCommands&lt;/code&gt;属性，以便在GDB启动后对其进行设置，大致的配置文件如下：&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.zhengi.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Kernel" scheme="https://blog.zhengi.me/categories/%E6%8A%80%E6%9C%AF/Kernel/"/>
    
    
    <category term="Linux" scheme="https://blog.zhengi.me/tags/Linux/"/>
    
    <category term="Kernel" scheme="https://blog.zhengi.me/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>使用Qemu和GDB对Linux内核进行调试</title>
    <link href="https://blog.zhengi.me/debug-linux-kernel-with-qemu-and-gdb/"/>
    <id>https://blog.zhengi.me/debug-linux-kernel-with-qemu-and-gdb/</id>
    <published>2020-05-02T09:11:29.000Z</published>
    <updated>2024-03-23T06:03:16.943Z</updated>
    
    <content type="html"><![CDATA[<p>使用Qemu对Linux内核进行调试是一种较为便捷的方式，近日进行了一番实践，并将大致步骤与其中一些小坑记录了下来。</p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>由于放长假赋闲在家，所以手头只有一台装有MacOS的MBP可用，而Linux内核的开发与调试使用Linux环境下会比较方便，所以就使用VMware Fusion创建了一台安装有Ubuntu 18.04系统的虚拟机。由于编译Linux内核及相关软件需要的资源较多，所以为虚拟机配置了双核CPU、2GB内存和20GB磁盘空间（笔记本本身资源有限），但实际使用（特别是物理内存和硬盘）捉襟见肘，于是又在系统中添加了3GB的SWAP内存并扩容了20GB的磁盘空间（其实还是不太够）才解决问题。</p><h1 id="编译Linux内核"><a href="#编译Linux内核" class="headerlink" title="编译Linux内核"></a>编译Linux内核</h1><p>首先，尝试对内核进行编译，在编译前需要使用通过KConfig启动内核的调试配置。</p><h2 id="下载内核源码"><a href="#下载内核源码" class="headerlink" title="下载内核源码"></a>下载内核源码</h2><p>由于Linux内核代码量非常大，且由于国内网络大家都懂的原因，所以的下载内核源码是一项较为复杂的体力活动。</p><span id="more"></span><p>第一种方法是直接Clone Linux源码的Git仓库，当前，其仓库大约为3.7GB。在通过内核官网(<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/</a>)或者GitHub(<a href="https://github.com/torvalds/linux">https://github.com/torvalds/linux</a>)进行Clone的过程中，经常会遇到连接断开的情况，非常捉急。而如果通过国内镜像源，如<a href="https://mirror.tuna.tsinghua.edu.cn/help/linux.git/">清华Kernel Git镜像</a>进行Clone的时候，最开始速度飞快，但是后面速度会越来越慢。因此，如果不像我这样头铁的话，不建议使用这样的方式下载Kernel的源码。</p><p>另一种较为简单的方式是下载特定版本的源码，这些源码的tarball包可以从<a href="https://www.kernel.org/">内核官网</a>或者镜像站获得。我在实验中使用的内核版本为4.19，gz压缩包的大小约为150MB。</p><h2 id="配置内核"><a href="#配置内核" class="headerlink" title="配置内核"></a>配置内核</h2><p>如果是使用Git Clone的方式获取的内核源码，需要通过<code>git checkout v4.19</code>将内核源码置位4.19版本。</p><p>在编译之前，首先需要安装相关的依赖（如果提示缺少其它依赖按需安装即可）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libncurses5-dev libssl-dev bison flex libelf-dev gcc make openssl libc6-dev</span><br></pre></td></tr></table></figure><p>在编译之前，需要使用KConfig对内核编译选项进行配置，在内核文件夹下，使用<code>make menuconfig</code>（命令行界面）或<code>make gconfig</code>（基于gtk的图形化界面）对内核进行配置。在配置时，需要打开如下选项：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">K<span class="function"><span class="title">ernel</span> hacking -&gt;</span> Kernel debugging</span><br><span class="line">K<span class="function"><span class="title">ernel</span> hacking -&gt;</span> KGDB:kernel debugger</span><br><span class="line">K<span class="function"><span class="title">ernel</span> hacking -&gt;</span> C<span class="function"><span class="title">ompile</span> <span class="built_in">time</span> checks <span class="built_in">and</span> compiler options -&gt;</span> Provide GDB scripts <span class="keyword">for</span> kernel debugging</span><br></pre></td></tr></table></figure><p>并保证如下选项没有开启：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">K<span class="function"><span class="title">ernel</span> hacking -&gt;</span> C<span class="function"><span class="title">ompile</span> <span class="built_in">time</span> checks <span class="built_in">and</span> compiler options -&gt;</span> Reduce debugging information</span><br></pre></td></tr></table></figure><p>在退出配置后，可以发现内核目录中生成了一个名为<code>.config</code>的配置文件。</p><h2 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h2><p>配置完成后，就可以使用<code>make</code>编译内核，在多核CPU中可以使用<code>make -jx</code>启动多线程编译（x为启动的线程数）。</p><p>如果一切正常，在漫长的等待后，内核将编译完成。编译会在内核根目录下生成<code>vmlinux  </code>文件，它是编译出的原始内核文件（含有调试信息），而会在<code>arch/x86/boot/bzImage</code>目录下生成压缩后的内核文件（当然是在编译的体系结构为x86的情况下）。</p><h1 id="编译安装GDB和Qemu"><a href="#编译安装GDB和Qemu" class="headerlink" title="编译安装GDB和Qemu"></a>编译安装GDB和Qemu</h1><p>由于内核调试所需的GDB和Qemu版本可能会比apt源中的版本高，所以，最好自行编译安装这些软件。</p><h2 id="编译安装GDB"><a href="#编译安装GDB" class="headerlink" title="编译安装GDB"></a>编译安装GDB</h2><p>首先，从官网(<a href="http://www.gnu.org/software/gdb/download/">http://www.gnu.org/software/gdb/download/</a>)下载GDB的源码并解压（这里使用的是官网中最新的GDB 9.1），需要注意的是，网上有些博客中提到需要修改GDB的源码，其实是不必要的，报错的原因是没有自动检测到目标体系结构的类型，所以只需设置该类型即可。</p><p>解压后进入GDB文件夹，执行下列指令，即可完成编译安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build </span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">../configure</span><br><span class="line">make -j4</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>最后，通过使用<code>gdb -v</code>确定gdb的版本是否为9.1，如果是，则说明安装成功。</p><h2 id="编译安装Qemu"><a href="#编译安装Qemu" class="headerlink" title="编译安装Qemu"></a>编译安装Qemu</h2><p>首先，从官网下载(<a href="https://www.qemu.org/download/#source">https://www.qemu.org/download/#source</a>)Qemu的源码并解压（这里使用的是Qemu 5.0.0）。</p><p>由于在Ubuntu GUI中使用Qemu还需要多媒体图形库SDL，所以需要首先使用apt安装sdl：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libsdl2-2.0-0 libsdl2-dev libsdl2-gfx-1.0-0 libsdl2-gfx-dev libsdl2-image-2.0-0 libsdl2-image-dev </span><br></pre></td></tr></table></figure><p>进入Qemu目录后，执行<code>./configure</code>检查系统配置并生成Makefile，需要注意检查的时候是否检测到了SDL的支持，其输出的部分内容如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">profiler          no</span><br><span class="line">static build      no</span><br><span class="line">SDL support       <span class="built_in">yes</span> (2.0.8)</span><br><span class="line">SDL image support <span class="built_in">yes</span></span><br><span class="line">GTK support       no </span><br><span class="line">GTK GL support    no</span><br><span class="line">VTE support       no </span><br><span class="line">TLS priority      NORMAL</span><br></pre></td></tr></table></figure><p>然后执行<code>make &amp;&amp; make install</code>即可完成Qemu的编译与安装。</p><p>在安装完Qemu后，会生成如<code>qemu-xxx</code>和<code>qemu-system-xxx</code>的一系列命令，用于仿真不同体系结构的用户态应用和操作系统，可以通过如<code>qemu-system-x86_64 --version</code>命令确认Qemu是否安装成功。</p><h1 id="制作ROOTFS"><a href="#制作ROOTFS" class="headerlink" title="制作ROOTFS"></a>制作ROOTFS</h1><p>在内核启动后需要一个带有init程序的rootfs，所以在调试内核前需要制作一个rootfs。</p><h2 id="构建基于initrd的rootfs"><a href="#构建基于initrd的rootfs" class="headerlink" title="构建基于initrd的rootfs"></a>构建基于initrd的rootfs</h2><p>initrd是一种位于内存的根文件系统，它可以在硬盘被驱动之前载入系统。这里为了方便，只将一个简单的程序写入initrd，并将其作为init程序（即系统启动后的第一个用户态进程）。除此之外，也可以使用busybox作为initrd中的init程序。</p><p>创建一下简单的c程序，命名为<code>fakeinit.c</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello linux!&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello linux!&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用gcc编译这段代码，在编译的时候需要使用静态链接，并且如果如果在配置内核的时候没有启用64位支持（64-bit kernel），则需要将代码编译为32位程序，方法是在gcc命令行中添加<code>-m32</code>选项。</p><p>编译命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc --static -o fakeinit fakeinit.c</span><br><span class="line">gcc --static -o fakeinit fakeinit.c -m32 (编译为32位可执行程序)</span><br></pre></td></tr></table></figure><p>在编译后，使用cpio程序进行打包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> fakeinit | cpio -o --format=newc &gt; initrd_rootfs.img</span><br></pre></td></tr></table></figure><p>这样，一个基于initrd的rootfs即制作完成。</p><h2 id="构建基于硬盘镜像的rootfs"><a href="#构建基于硬盘镜像的rootfs" class="headerlink" title="构建基于硬盘镜像的rootfs"></a>构建基于硬盘镜像的rootfs</h2><p>这里使用busybox构建基于硬盘镜像的rootfs。其中，busybox是一个集成了数百个Linux常用命令和工具的单个软件，在对内核进行测试的时候非常方便，号称“The Swiss Army Knife of Embedded Linux”。</p><h3 id="下载编译busybox"><a href="#下载编译busybox" class="headerlink" title="下载编译busybox"></a>下载编译busybox</h3><p>首先，从官网(<a href="https://busybox.net/downloads/">https://busybox.net/downloads/</a>)下载busybox的源码并解压（这里使用的是最新的busybox-1.31.1）。</p><p>在解压并进入busybox文件夹后，首先使用<code>make gconfig</code>或<code>make menuconfig</code>对其进行配置，需要启用如下选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Settings -&gt; Build Options -&gt; Build static binary (no shared libs)</span><br></pre></td></tr></table></figure><p>如果需要将其编译为32位版本，则需要将<code>-m32</code>命令填入如下选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Settings -&gt; Build Options -&gt; Additional CFLAGS</span><br><span class="line">Settings -&gt; Build Options -&gt; Additional LDFLAGS</span><br></pre></td></tr></table></figure><p>与内核相同，在退出后，会在目录中生成一个名为<code>.config</code>的配置文件。</p><p>然后，使用<code>make</code>命令编译busybox。</p><h3 id="使用busybox创建rootfs"><a href="#使用busybox创建rootfs" class="headerlink" title="使用busybox创建rootfs"></a>使用busybox创建rootfs</h3><p>首先，创建一个空的磁盘镜像文件，然后将其格式化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=./busybox_rootfs.img bs=1M count=10</span><br><span class="line">mkfs.ext3 ./busybox_rootfs.img</span><br></pre></td></tr></table></figure><p>然后，挂载刚刚创建的磁盘镜像（需要使用loop设备）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> rootfs_mount</span><br><span class="line">sudo mount -t ext3 -o loop ./busybox_rootfs.img ./rootfs_mount</span><br></pre></td></tr></table></figure><p>接着，在busybox源码目录中，将编译好的busybox目标文件安装到rootfs文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install CONFIG_PREFIX=/path/to/rootfs_mount/</span><br></pre></td></tr></table></figure><p>最后，配置busybox的init，并卸载rootfs：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /path/to/rootfs_mount/proc</span><br><span class="line"><span class="built_in">mkdir</span> /path/to/rootfs_mount/dev</span><br><span class="line"><span class="built_in">mkdir</span> /path/to/rootfs_mount/etc</span><br><span class="line"><span class="built_in">cp</span> busybox-source-code/examples/bootfloppy/* /path/to/rootfs_mount/etc/</span><br><span class="line">sudo umount /path/to/rootfs_mount</span><br></pre></td></tr></table></figure><p>现在，一个基于busybox的rootfs磁盘镜像就制作成功了。</p><h1 id="使用Qemu和GDB调试内核"><a href="#使用Qemu和GDB调试内核" class="headerlink" title="使用Qemu和GDB调试内核"></a>使用Qemu和GDB调试内核</h1><h2 id="使用Qemu启动内核"><a href="#使用Qemu启动内核" class="headerlink" title="使用Qemu启动内核"></a>使用Qemu启动内核</h2><p>由于编译的内核体系结构为x86，所以使用<code>qemu-system-x86_64</code>程序来载入并启动内核。</p><p>如果使用intird作为rootfs，则具体命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">  -kernel ./linux/arch/x86/boot/bzImage \  <span class="comment"># 指定编译好的内核镜像</span></span><br><span class="line">  -initrd ./rootfs/initrd_rootfs.img \  <span class="comment"># 指定rootfs</span></span><br><span class="line">  -serial stdio \ <span class="comment">#指定使用stdio作为输入输出</span></span><br><span class="line">  -append <span class="string">&quot;root=/dev/ram rdinit=/fakeinit console=ttyS0 nokaslr&quot;</span> \ <span class="comment"># 内核参数，指定使用initrd作为rootfs，禁止地址空间布局随机化</span></span><br><span class="line">  -s -S <span class="comment"># 指定Qemu在启动时暂停并启动gdb server，等待gdb的连入（端口默认为1234）</span></span><br></pre></td></tr></table></figure><p>如果使用磁盘镜像作为rootfs，则具体命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">  -kernel ./linux/arch/x86/boot/bzImage \</span><br><span class="line">  -hda ./rootfs/busybox_rootfs.img \ <span class="comment"># 指定磁盘镜像</span></span><br><span class="line">  -serial stdio \</span><br><span class="line">  -append <span class="string">&quot;root=/dev/sda console=ttyS0 nokaslr&quot;</span> \ <span class="comment"># 内核参数，指定root磁盘，禁止地址空间布局随机化</span></span><br><span class="line">  -s -S</span><br></pre></td></tr></table></figure><h2 id="使用GDB调试内核"><a href="#使用GDB调试内核" class="headerlink" title="使用GDB调试内核"></a>使用GDB调试内核</h2><p>最后一步，由于刚刚Qemu开启了远程调试，所以只需要将gdb通过连入即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb ./linux/vmlinux <span class="comment"># 指定调试文件为包含调试信息的内核文件</span></span><br></pre></td></tr></table></figure><p>如果此时直接在gdb调试器中使用<code>target remote:1234</code>连入Qemu的gdb server，则会出现报错<code>Remote ‘g’ packet reply is too long</code>，这是由于gdb没有正确识别调试目标的体系结构造成的（有些博客认为需要修改源代码屏蔽这个错误，实际上是不必要的），所以只需要在远程attach之前使用<code>set arch i386:x86-64:intel</code>设置目标体系结构即可。</p><p>例如，你希望在start_kernel函数设置断点进行调试，则在启动Qemu后，gdb的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gdb ~/linux/vmlinux</span><br><span class="line">(gdb) <span class="built_in">set</span> <span class="built_in">arch</span> i386:x86-64:intel</span><br><span class="line">(gdb) add-auto-load-safe-path ~/linux</span><br><span class="line">(gdb) target remote:1234</span><br><span class="line">(gdb) b start_kernel</span><br><span class="line">(gdb) c</span><br></pre></td></tr></table></figure><p>可以发现，内核在启动后被中断在start_kernel函数上。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><h2 id="内核文档"><a href="#内核文档" class="headerlink" title="内核文档"></a>内核文档</h2><p>在内核的文档中，有一篇详细讲解了如何使用GDB调试内核。</p><p>该文档的最新版本可见于内核的官网：<a href="https://www.kernel.org/doc/html/latest/dev-tools/gdb-kernel-debugging.html">https://www.kernel.org/doc/html/latest/dev-tools/gdb-kernel-debugging.html</a>。</p><p>而具体的版本就需要在内核源码中编译文档了，例如html版本的文档可以使用<code>make htmldocs</code>进行编译，在启动HTTP服务器后，可以在浏览器中进行访问，例如，<a href="http://127.0.0.1:8000/dev-tools/gdb-kernel-debugging.html">http://127.0.0.1:8000/dev-tools/gdb-kernel-debugging.html</a>。</p><h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2><p>本文参考了两篇较为优质的博客：</p><ul><li><a href="https://freemandealer.github.io/2015/10/04/debug-kernel-with-qemu-2/">用QEMU来调试内核 – 亲身体验篇 </a></li><li><a href="http://rainlin.top/archives/201">利用VS Code+Qemu+GDB调试Linux内核</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用Qemu对Linux内核进行调试是一种较为便捷的方式，近日进行了一番实践，并将大致步骤与其中一些小坑记录了下来。&lt;/p&gt;
&lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;p&gt;由于放长假赋闲在家，所以手头只有一台装有MacOS的MBP可用，而Linux内核的开发与调试使用Linux环境下会比较方便，所以就使用VMware Fusion创建了一台安装有Ubuntu 18.04系统的虚拟机。由于编译Linux内核及相关软件需要的资源较多，所以为虚拟机配置了双核CPU、2GB内存和20GB磁盘空间（笔记本本身资源有限），但实际使用（特别是物理内存和硬盘）捉襟见肘，于是又在系统中添加了3GB的SWAP内存并扩容了20GB的磁盘空间（其实还是不太够）才解决问题。&lt;/p&gt;
&lt;h1 id=&quot;编译Linux内核&quot;&gt;&lt;a href=&quot;#编译Linux内核&quot; class=&quot;headerlink&quot; title=&quot;编译Linux内核&quot;&gt;&lt;/a&gt;编译Linux内核&lt;/h1&gt;&lt;p&gt;首先，尝试对内核进行编译，在编译前需要使用通过KConfig启动内核的调试配置。&lt;/p&gt;
&lt;h2 id=&quot;下载内核源码&quot;&gt;&lt;a href=&quot;#下载内核源码&quot; class=&quot;headerlink&quot; title=&quot;下载内核源码&quot;&gt;&lt;/a&gt;下载内核源码&lt;/h2&gt;&lt;p&gt;由于Linux内核代码量非常大，且由于国内网络大家都懂的原因，所以的下载内核源码是一项较为复杂的体力活动。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.zhengi.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Kernel" scheme="https://blog.zhengi.me/categories/%E6%8A%80%E6%9C%AF/Kernel/"/>
    
    
    <category term="Linux" scheme="https://blog.zhengi.me/tags/Linux/"/>
    
    <category term="Kernel" scheme="https://blog.zhengi.me/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>在NodeJS中与C++代码通信</title>
    <link href="https://blog.zhengi.me/communicate_with_cpp_code_in_node/"/>
    <id>https://blog.zhengi.me/communicate_with_cpp_code_in_node/</id>
    <published>2019-10-22T15:24:34.000Z</published>
    <updated>2024-03-23T06:03:16.943Z</updated>
    
    <content type="html"><![CDATA[<p>最近在项目中遇到需要在 NodeJS 中调用 C++代码的问题，在此略作总结。</p><h1 id="主要方案"><a href="#主要方案" class="headerlink" title="主要方案"></a>主要方案</h1><p>在 NodeJS 中，和其他语言编写的代码通信主要有两种方案：</p><ul><li>使用 AddOn 技术，使用 C++为 NodeJS 编写一个拓展，然后在代码中调用其他语言所编写的源码 or 动态库</li><li>使用 FFI（Foreign Function Interface）技术，直接在 Node 中引入其他语言所编写的动态链接库</li></ul><p>在对这两种方式进行比较后，发现这两种方式各有优劣。</p><p>首先，AddOn 技术比较通用，它可以使用 C++代码来拓展 Node 的行为，很多库都是使用这种方式来完成一些比较底层操作（比如和操作系统的一些通信）的。但是它写起来比较麻烦，要编写一个 C++项目，还要按照 NodeJS 的规范 export 相应的函数，而且每次安装的时候都需要进行编译（以适应本地 Node 的版本）。如果只是调用一个 DLL，那就还需要在项目里重新包装一遍 DLL 的接口。</p><p>如果使用 FFI 技术，限制就会比较多,首先，它只能调用其他动态库，如果你想使用 C/C++完成更多功能的话，还需要再封装一层 DLL，另外，它只支持<code>_cdecl</code>调用约定（也就是 DLL 在导出的时候一定要标记用<code>_cdecl</code>编译命令），不支持<code>_stdcall</code>或者<code>_fastcall</code>调用。但是调用起来就会很方便，可以直接在 JS 代码中声明 DLL 的接口就可以了。</p><p>综上比较，如果只调用第三方 DLL（而且恰好是<code>_cdecl</code>导出），使用 FFI 就再合适不过了（虽然性能可能会有一定的损失，而且调试起来会有困难）。</p><p>其实，从理论上来讲，FFI 也是基于 AddOn 技术的，只是它可以帮你把在 JS 中定义的接口直接转换成 C 语言的接口，并利用 NodeJS 的 Buffer 内存，将其同载入的 DLL 共享。当然由于 FFI 的这种通用性，也导致了一定的性能损失。</p><p>下面就以在 Windows 平台上使用 FFI 为例，简单聊一下如何使用 NodeJS 和 C++编译而成的 DLL 通信吧。</p><span id="more"></span><h1 id="FFI-使用准备"><a href="#FFI-使用准备" class="headerlink" title="FFI 使用准备"></a>FFI 使用准备</h1><h2 id="安装-NodeJS"><a href="#安装-NodeJS" class="headerlink" title="安装 NodeJS"></a>安装 NodeJS</h2><p>可能你的环境中已经有 NodeJS 了，但是，如果是最新版本，在安装 FFI 的时候会出现各种兼容性的问题（比如编译无法通过，虽然已经有人提供了 patch，但是还没有被 merge 进主分支，为了避免出现 bug，还是暂时不用为妙）。所以可以安装 LTS 版本代替。</p><p>另外，还需要注意要调用的 DLL 是 32 位还是 64 位的，Node 的版本需要和 DLL 的版本匹配。因为如果 64 位 Node 调用了 32 位的 DLL，是无法成功装载的，反之亦然。</p><h2 id="安装-Windows-的-C-工具链"><a href="#安装-Windows-的-C-工具链" class="headerlink" title="安装 Windows 的 C++工具链"></a>安装 Windows 的 C++工具链</h2><p>这里有两种方案：</p><ul><li>安装 Visual Studio，并安装相应的工具链。如果使用 VS 2019 版本的话，需要安装 C++桌面开发和 Windows SDK 相关的工具（Node v10 现在只支持 v141 版本的 MSVC），这种方式便于后续的调试工作（虽然也很艰难）</li><li>在安装 Node 之后，使用管理员权限运行 Powershell，并全局安装 windows-build-tools，参考命令 <code>npm install --global --production windows-build-tools</code></li></ul><h2 id="安装-node-gyp"><a href="#安装-node-gyp" class="headerlink" title="安装 node-gyp"></a>安装 node-gyp</h2><p>node-gyp 是一个 Node 中基于 gyp 的跨平台的编译工具，用于编译其他库。</p><p>在安装的时候，需要使用 VC 的工具链，所以如果没有把工具链放在全局变量中，需要打开 VS 的<code>Developer Powershell</code>安装，该命令行一般在开始菜单的 Visual Studio 文件夹中。</p><p>参考命令：<code>npm install -g node-gyp</code></p><h2 id="安装-FFI-及-REF"><a href="#安装-FFI-及-REF" class="headerlink" title="安装 FFI 及 REF"></a>安装 FFI 及 REF</h2><p>下面的步骤依旧需要 VC 工具链，所以可能依旧需要在<code>Developer Powershell</code>中执行（建议常备该窗口，后面只要涉及到编译安装的命令都需要用到）。</p><p>安装 FFI 及相关工具的时候如果没有 VC 工具链，则会直接安装二进制代码，这样可能会出现包的 ABI 版本和 NodeJS 的 ABI 版本不符合的情况（在下面的 Tips 中会提到）。</p><p>现在，切换到项目的文件夹中，安装下面的包。其中，ffi 包是用以支持 FFI 功能的，ref 包是用以支持指针功能（原理是通过 Node 的 Buffer 内存，将 JS 的结构和 C 结构相互转换的）的，ref-*是用以支持高级结构的（比如数组和结构体）</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install ffi <span class="literal">-s</span></span><br><span class="line">npm install ref <span class="literal">-s</span></span><br><span class="line">npm install ref<span class="literal">-array</span> <span class="literal">-s</span></span><br><span class="line">npm install ref<span class="literal">-struct</span> <span class="literal">-s</span></span><br></pre></td></tr></table></figure><p>除此之外，如果想支持 VC 中常见的 wchar 类型，还可以安装 ref-wchar 包。</p><h2 id="安装-electron-rebuild-包"><a href="#安装-electron-rebuild-包" class="headerlink" title="安装 electron-rebuild 包"></a>安装 electron-rebuild 包</h2><p>如果是 electron 项目，还推荐安装 electron-rebuild 包，该包可以遍历 node_modules 目录下的所有包，并将其重新编译。</p><p>然后，推荐在 package.json 中配置 electron-rebuild 的命令：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;rebuild&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./node_modules/.bin/electron-rebuild&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>之后执行在需要重新编译的时候只需要执行<code>npm run rebuild</code>即可。</p><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><h2 id="简单概览"><a href="#简单概览" class="headerlink" title="简单概览"></a>简单概览</h2><p>可以查看如下官方示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ffi = <span class="built_in">require</span>(<span class="string">&#x27;ffi&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> libm = ffi.<span class="title class_">Library</span>(<span class="string">&#x27;libm&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">ceil</span>: [<span class="string">&#x27;double&#x27;</span>, [<span class="string">&#x27;double&#x27;</span>]]</span><br><span class="line">&#125;)</span><br><span class="line">libm.<span class="title function_">ceil</span>(<span class="number">1.5</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>在引入 FFI 后，使用 FFI 调用了 libm 库（可能这个示例只能在类 Unix 系统中使用），一般拓展名为 libm.so，系统会在系统目录下搜索这个动态库，并将它使用动态链接器载入到 node 进程中。</p><p>接着，程序声明了 libm 库中的一个方法 ceil（向上取整），其中，该函数的返回值是 double 类型（第一重数组中的 doule），而该函数的入参也是一个 double 类型的值（第二重数组中的 double）。</p><p>最后，直接使用<code>libm.ceil</code>方法即可调用动态库中的函数，并返回正确的值。</p><p>这只是一个 FFI 的简单用例，更复杂的用法（主要是异步调用和回调函数）可以参考 FFI 的实例页<a href="https://github.com/node-ffi/node-ffi/wiki/Node-FFI-Tutorial">https://github.com/node-ffi/node-ffi/wiki/Node-FFI-Tutorial</a>。</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>FFI 的类型系统其实记住了 ref 库的类型，ref 库的类型系统基于 NodeJS 的 Buffer 内存，可以根据 Buffe 中数据的类型对 Buffer 内存中的数据进行访问和修改。</p><p>ref 自带的数据类型都是基本类型，比如 int 类型、bool 类型或者 string 类型。所有类型可以参考 ref 的<a href="https://github.com/TooTallNate/ref/wiki/Known-%22types%22">wiki</a>。</p><p>ref 中的多数类型都有简写，比如<code>ref.types.int</code>可以简写为<code>int</code>。</p><p>需要注意的是，<code>char*</code>可以写为<code>string</code>，对应的 ref 类型为<code>ref.types.CString</code>。值得注意的是，string 在 JS 中是基本类型，在 C 中却是引用类型。</p><p>对于指针类型，ref 提供了一个方法<code>ref.refType()</code>来得到，比如<code>int*</code>类型就可以使用<code>ref.refType(&#39;int&#39;)</code>得到。当然，为了省事，也可以直接用<code>int*</code>表示。</p><p>而对指针解引用，ref 库也提供了一个<code>deref()</code>方法。只要在对应类型的变量上使用该方法，就可以得到指针指向内容的变量。比如一个指向<code>int*</code>类型的 JS 变量 a_pointer，那么我们如果想得到具体的整数值，就可以使用<code>a_pointer.deref()</code>方法。</p><p>相反的，如果想获取某个变量的地址，就需要对某个变量使用<code>ref()</code>方法。</p><p>需要注意掌握类型与变量值的区别，使用<code>ref.types</code>、<code>ref.refType</code>或者是下面会提到的<code>ref_struct(&#123;...&#125;)</code>获得的类型，而如果想获得某个类型的变量，有两个方法，一个是从 FFI 函数的返回值中获取，另一个是在 Buffer 中开辟一个空间，来存放类型为所获得类型的变量，下面会具体讲到。</p><p>如果需要在 NodJS 的 Buffer 中开辟长度为某个类型的空间，可以使用<code>ref.alloc()</code>函数，只要将类型名传入即可。比如，想开辟一个类型为 int 的内存，就可以使用<code>ref.alloc(&#39;int&#39;)</code>得到。</p><p>此外，还有以下几点需要注意：</p><ul><li>如果开辟类型为字符串的内存，推荐使用方法 ref.allocCString，其参数为一个 JS 的字符串。因为 C 语言的字符串在末尾有一个<code>\0</code>标识符，所以用这个方法可以更安全地得到 C 字符串。</li><li>如果在 C 语言中值为 NULL，则在 JS 中对应的值为 ref.NULL。</li><li>如果遇到指针类型，可以统一用<code>&#39;void&#39;</code>或者<code>ref.types.void</code>表示。</li><li>如果要表示一个函数的指针，可以使用<code>&#39;pointer&#39;</code>表示。</li></ul><p>对于复合类型，比如数组或者结构体，ref 库本身没有提供相应的支持，需要使用 ref-array 和 ref-struct 库来实现，具体可以参考这两个库的文档。</p><p>另外，对于 Windows API 中较为常见的宽字符 wchar 类型，也有一个基于 ref 的库 ref-wchar 进行支持。</p><p>最后，附上 ref 的文档<a href="http://tootallnate.github.io/ref/">http://tootallnate.github.io/ref/</a>，具体的 API 都可以在这里进行查阅。</p><h2 id="调用外部符号"><a href="#调用外部符号" class="headerlink" title="调用外部符号"></a>调用外部符号</h2><p>假设我们有如下 C 代码（并把它写的复杂一些）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">t_s_t</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">&#125; t_s;</span><br><span class="line"></span><br><span class="line">__declspec(dllexport) <span class="type">int</span> <span class="title function_">add_one</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__declspec(dllexport) <span class="type">void</span> <span class="title function_">struct_test</span><span class="params">(t_s** t_s_p)</span> &#123;</span><br><span class="line">    *t_s_p = (t_s *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(t_s));</span><br><span class="line">    (*t_s_p)-&gt;a = <span class="number">1</span>;</span><br><span class="line">    (*t_s_p)-&gt;b = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，声明了一个结构体<code>t_s</code>，以及两个函数<code>add_one</code>和<code>struct_test</code>。其中，函数前面的<code>__declspec</code>标记表示声明该函数为导出函数。VC 默认导出 C 函数时是用<code>_cdecl</code>调用约定。</p><p>其中，<code>add_one</code>方法的作用显而易见，是将传入参数加一再返回。而<code>struct_test</code>函数的作用是先在堆上开辟一个大小为生面声明结构体的内存空间，然后将该内存空间的指针赋给传入的参数，并将该结构体赋值。（这里的代码其实不够严谨，没有进行内存回收，但这不是本文的重点，所以先不做讨论）</p><p>需要注意的是，如果是 C++代码，需要使用<code>extern &quot;C&quot;</code>标记导出，否则会因为符号修饰和调用约定的问题导致无法通过源代码中的符号找到该函数。</p><p>我们可以使用 VS 的<code>Developer Powershell</code>对上述源码进行编译：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cl /c main.c</span><br><span class="line">Link /dll main.obj</span><br></pre></td></tr></table></figure><p>编译后将生成 main.dll，我们在后面会用到这个动态库。</p><p>针对上述 C 函数，我们有如下 JS 代码，并假设和 C 代码在同一文件夹下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* index.js */</span></span><br><span class="line"><span class="keyword">const</span> ffi = <span class="built_in">require</span>(<span class="string">&#x27;ffi&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> ref = <span class="built_in">require</span>(<span class="string">&#x27;ref&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> ref_struct = <span class="built_in">require</span>(<span class="string">&#x27;ref-struct&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> t_s = <span class="title function_">ref_struct</span>(&#123;</span><br><span class="line">  <span class="attr">a</span>: ref.<span class="property">types</span>.<span class="property">int</span>,</span><br><span class="line">  <span class="attr">b</span>: ref.<span class="property">types</span>.<span class="property">char</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> t_s_ref = ref.<span class="title function_">refType</span>(t_s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test_ffi = ffi.<span class="title class_">Library</span>(__dirname + <span class="string">&#x27;\\main&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">add_one</span>: [<span class="string">&#x27;int&#x27;</span>, [<span class="string">&#x27;int&#x27;</span>]],</span><br><span class="line">  <span class="comment">// aka &#x27;add_one&#x27;: [ref.types.int, [&#x27;int&#x27;]],</span></span><br><span class="line">  <span class="attr">struct_test</span>: [<span class="string">&#x27;void&#x27;</span>, [<span class="string">&#x27;pointer&#x27;</span>]]</span><br><span class="line">  <span class="comment">// aka &#x27;struct_test&#x27;: [&#x27;void&#x27;, [t_s_ref]],</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> result = test_ffi.<span class="title function_">add_one</span>(<span class="number">20</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result) <span class="comment">//21</span></span><br><span class="line"></span><br><span class="line">t_s_p = ref.<span class="title function_">alloc</span>(t_s_ref)</span><br><span class="line">test_ffi.<span class="title function_">struct_test</span>(t_s_p)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(t_s_p)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(t_s_p.<span class="title function_">deref</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(t_s_p.<span class="title function_">deref</span>().<span class="title function_">deref</span>()) <span class="comment">//a-&gt;1, b-&gt;&#x27;d&#x27;</span></span><br></pre></td></tr></table></figure><p>首先，在代码中声明了一个结构体<code>t_s</code>,和 C 语言中的<code>t_s*</code>类型相对应。然后，我们还得到了结构体<code>t_s</code>的一个引用<code>t_s_ref</code>，和 C 语言中的<code>t_s**</code>类型对应。为什么在 C 语言中都多了一层指针呢？其原因和前面的字符串一样。</p><p>然后，声明了 test_ffi 变量，它调用了 ffi.Library 方法，该方法返回了 JS 中 DLL 的句柄和函数的声明，通过该变量可以进行 DLL 的调用。该方法有两个参数，一个是动态库的名称（可以略去拓展名 dll），另一个就是描述 C 语言函数的符号及其参数的对象。</p><p>该列表在上面已经简单介绍过了，对象的 key 是函数名，value 是一个数组，数组中第一个元素为函数的返回值的类型，第二个元素为另一个数组，它里面包含了函数的入参的类型。这些类型就用到了上一节中介绍的基于 ref 包的类型系统，类型可以用字符串表示，也可以用代码表示，可以参考代码中 aka 的注释。</p><p>接下来，代码通过<code>test_ffi.add_one</code>调用了 C 语言动态库中的<code>add_one</code>函数，可以看出，调用的方式和 JS 中的函数并无二致。但是需要注意参数类型千万不能传错，特别要注意 C 语言的 string 类型和 JS 中的 string 类型不同，要按照前文提到的方法进行转换。</p><p>然后，代码使用 ref.alloc 方法为 t_s_ref 变量开辟了一个内存空间（注意这只是一个指针大小的空间，并非结构体大小），并将该地址赋给 t_s_p 变量，然后将该变量传递给 struct_test 函数。因为 t_s_p 是一个二重指针，所以需要解两次引用，才能得到结构体真实的值。</p><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>回调函数可以使用<code>ffi.Callback()</code>函数声明，该函数的第一个参数为返回值，第二个参数为入参列表，第三个参数为真实回调函数的闭包。</p><p>比如一个回调函数的定义如下，该函数会得到用户名和 id，并返回动作是否执行成功：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span><span class="params">(*callback)</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">char</span>*)</span>;</span><br></pre></td></tr></table></figure><p>那么，在 ffi 中，就可以使用如下方式声明该回调函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> callback_function = ffi.<span class="title class_">Callback</span>(<span class="string">&#x27;int&#x27;</span>, [<span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;string&#x27;</span>], <span class="function">(<span class="params">id, username</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在声明之后，需要将该回调函数做为参数传入某个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test_ffi.<span class="title function_">set_a_callback</span>(callback_function)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make an extra reference to the callback pointer to avoid GC</span></span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;exit&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  callback_function</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>特别需要注意的是，设置完回调函数以后一定要保证该函数在 JS 中还存在一个引用（比如上面讲该函数的一个引用放在了 NodeJS 的 exit 事件中，这也是比较经典的做法）。否则，该函数将会被 NodeJS 的 GC 析构。其表现是：在程序刚开始执行的时候一切正常，但是执行了一会儿之后在调用这个回调函数，程序就会异常退出。如果用 VS 去对程序 Debug，就会发现该程序可能访问了非法指针，这是因为 DLL 代码中也存放了该回调函数的指针，但是在 JS 中该指针指向的地址因为没有被 JS 中的代码引用，所以被 CG 被释放，这样 DLL 中代码调用该地址的函数的时候，就会访问到非法的内存。</p><h1 id="一些-Tips"><a href="#一些-Tips" class="headerlink" title="一些 Tips"></a>一些 Tips</h1><h2 id="DLL-的调试方法"><a href="#DLL-的调试方法" class="headerlink" title="DLL 的调试方法"></a>DLL 的调试方法</h2><p>在使用 ffi 的过程中，可能发现最大的问题就是程序难以调试。特别在面对 DLL 的时候，就像针对一个黑盒操作一样，虽然已经对着头文件将他的 API 使用 FFI 翻译为 JS 的代码，但还是难以确定传参或返回值是否正确，在 C++的代码中该参数是否正确传入，传入后是否正确执行等等。这就需要一个能够调试的方法。</p><p>一个比较好用的方式是使用宇宙第一 IDE Visual Studio 的 Attach（附加）到进程的方式进行调试。但这种调试方法的前提是手中有 DLL 的源码或 PDB（符号）文件（如果没有的话就只能看到出现异常的代码附近的反汇编的代码了，而通常这些异常都是内存错误引起的，其实它附近的数据可能没有多大的意义）。</p><p>如果手上有源文件，那么首先打开工程，然后在 NodeJS 载入 DLL 之后，就可以在启动工程的时候选择“附加到进程”，在对话框中选择 NodeJS 进程即可进入调试界面。在调试界面里，可以插入断点，也可以看到断点附近的内存。</p><p>如果手上没有源文件，但是有 PDB 文件（或者少量的源码），可以使用 VS 打开一个空工程，然后在调试的设置中添加符号文件的位置，这样也可以进行断点调试，在调试的过程中可以查看代码有没有命中断点，在命中断点时，会引导你载入项目文件，如果有的话可以选择，否则可以查看断点附近的反汇编代码。</p><p>具体的调试方法可以参考 MSDN 文档：<a href="https://docs.microsoft.com/en-us/visualstudio/debugger/attach-to-running-processes-with-the-visual-studio-debugger?view=vs-2019">https://docs.microsoft.com/en-us/visualstudio/debugger/attach-to-running-processes-with-the-visual-studio-debugger?view=vs-2019</a>，在这里就不过多叙述了。</p><h2 id="如何载入在其他文件夹中的-DLL"><a href="#如何载入在其他文件夹中的-DLL" class="headerlink" title="如何载入在其他文件夹中的 DLL"></a>如何载入在其他文件夹中的 DLL</h2><p>如果 JS 文件和 DLL 文件不在同一文件夹中，可能会出现载入失败，会出现类似于“Dynamic Linking Error: Win32 error 126”的错误提示。</p><p>这时，就需要将 DLL 文件夹的路径放在系统寻找动态链接库的 PATH 中，但是 FFI 并没有提供此类接口。不过，好在 Windows API 提供了 SetDllDirectoryA 这个接口用以切换该进程中寻找 DLL 的 PATH，可以使用如下代码完成这个操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> kernel32_ffi = ffi.<span class="title class_">Library</span>(<span class="string">&#x27;kernel32&#x27;</span>, &#123;</span><br><span class="line">  <span class="title class_">SetDllDirectoryA</span>: [<span class="string">&#x27;bool&#x27;</span>, [<span class="string">&#x27;string&#x27;</span>]]</span><br><span class="line">&#125;)</span><br><span class="line">kernel32_ffi.<span class="title class_">SetDllDirectoryA</span>(your_custom_dll_directory)</span><br></pre></td></tr></table></figure><h2 id="一些链接时候的错误提示"><a href="#一些链接时候的错误提示" class="headerlink" title="一些链接时候的错误提示"></a>一些链接时候的错误提示</h2><p>上面已经提到，如果动态库不在 PATH 中的话，会出现无法找到动态库的情况，这时候会报“Dynamic Linking Error: Win32 error 126”的错误，在另外一些时候，只要没有找到动态库，都会报该错误。如果出现该错误，就需要检查动态库的名称是否正确，检查动态库的版本是否正确（比如 32 位 Node 使用了 64 位的 DLL）等。</p><p>另外，还有一个“Dynamic Linking Error: Win32 error 127”错误比较常见，该错误指没有在 DLL 中找到对应的符号，这可能就需要检查在 ffi 中声明的函数名是否正确以及是否 DLL 版本有偏差了。</p><h2 id="在-Electron-中使用-FFI"><a href="#在-Electron-中使用-FFI" class="headerlink" title="在 Electron 中使用 FFI"></a>在 Electron 中使用 FFI</h2><p>由于每一个 Electron 的版本是基于相应的 Node 和 Chrome 版本构建的，所以在使用 FFI 之前需要根据所使用的 Electron 版本安装本地的 NodeJS 版本，否则 FFI 可能会和 Node 版本不匹配，导致提示 ABI 版本不一致：<code>xx was compiled against a different Node.js version using NODE_MODULE_VERSION x. This version of Node.js requires NODE_MODULE_VERSION xx</code>（NodeJS 使用 NODE_MODULE_VERSION 来辨别 ABI 版本）。</p><p>这种情况下，可以使用前文提到的<code>electron-rebuild</code>对项目中的所有插件进行重新编译（需要注意本地 NodeJS 的 ABI 版本一定要和 Electron 中 NodeJS 的 ABI 版本一致）。</p><p>另外，需要注意的是，Electron 5 以上的版本使用了 NodeJS 12 的 ABI，但是当前的 Ref 库并不支持该 ABI，会导致编译失败。不过已经有人提交了 pull request 进行修复，相信之后会有一个可用的版本出来。</p><p>另外，也有了 NAPI 版本的 FFI 和 Ref，分别名为<code>ffi-napi</code>和<code>ref-napi</code>，和 ref 相关的包，比如 array 和 struct 拓展，也有了相应的 NAPI 版本，命名规则同上。使用 NAPI 的 Node C++ 拓展接口相对稳定，是今后的趋势。</p><p>最后，Electron 版本可以在<a href="https://electronjs.org/releases/stable">https://electronjs.org/releases/stable</a>中查看，而 NodeJS 及其 ABI 的版本可以在<a href="https://nodejs.org/en/download/releases/">https://nodejs.org/en/download/releases/</a>中查看。</p><h1 id="一些资源"><a href="#一些资源" class="headerlink" title="一些资源"></a>一些资源</h1><p>最后，在这里放上最近踩坑时候经常使用到的一些资源吧：</p><ul><li>ref 文档：<a href="http://tootallnate.github.io/ref/">http://tootallnate.github.io/ref/</a></li><li>ffi 文档：<a href="https://github.com/node-ffi/node-ffi/wiki/Node-FFI-Tutorial">https://github.com/node-ffi/node-ffi/wiki/Node-FFI-Tutorial</a></li><li>基于 ffi 的 win32 api：<a href="https://github.com/waitingsong/node-win32-api">https://github.com/waitingsong/node-win32-api</a></li><li>v2ex 中的 node-ffi 食用指南（难吃）：<a href="https://www.v2ex.com/amp/t/474611">https://www.v2ex.com/amp/t/474611</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在项目中遇到需要在 NodeJS 中调用 C++代码的问题，在此略作总结。&lt;/p&gt;
&lt;h1 id=&quot;主要方案&quot;&gt;&lt;a href=&quot;#主要方案&quot; class=&quot;headerlink&quot; title=&quot;主要方案&quot;&gt;&lt;/a&gt;主要方案&lt;/h1&gt;&lt;p&gt;在 NodeJS 中，和其他语言编写的代码通信主要有两种方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 AddOn 技术，使用 C++为 NodeJS 编写一个拓展，然后在代码中调用其他语言所编写的源码 or 动态库&lt;/li&gt;
&lt;li&gt;使用 FFI（Foreign Function Interface）技术，直接在 Node 中引入其他语言所编写的动态链接库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在对这两种方式进行比较后，发现这两种方式各有优劣。&lt;/p&gt;
&lt;p&gt;首先，AddOn 技术比较通用，它可以使用 C++代码来拓展 Node 的行为，很多库都是使用这种方式来完成一些比较底层操作（比如和操作系统的一些通信）的。但是它写起来比较麻烦，要编写一个 C++项目，还要按照 NodeJS 的规范 export 相应的函数，而且每次安装的时候都需要进行编译（以适应本地 Node 的版本）。如果只是调用一个 DLL，那就还需要在项目里重新包装一遍 DLL 的接口。&lt;/p&gt;
&lt;p&gt;如果使用 FFI 技术，限制就会比较多,首先，它只能调用其他动态库，如果你想使用 C/C++完成更多功能的话，还需要再封装一层 DLL，另外，它只支持&lt;code&gt;_cdecl&lt;/code&gt;调用约定（也就是 DLL 在导出的时候一定要标记用&lt;code&gt;_cdecl&lt;/code&gt;编译命令），不支持&lt;code&gt;_stdcall&lt;/code&gt;或者&lt;code&gt;_fastcall&lt;/code&gt;调用。但是调用起来就会很方便，可以直接在 JS 代码中声明 DLL 的接口就可以了。&lt;/p&gt;
&lt;p&gt;综上比较，如果只调用第三方 DLL（而且恰好是&lt;code&gt;_cdecl&lt;/code&gt;导出），使用 FFI 就再合适不过了（虽然性能可能会有一定的损失，而且调试起来会有困难）。&lt;/p&gt;
&lt;p&gt;其实，从理论上来讲，FFI 也是基于 AddOn 技术的，只是它可以帮你把在 JS 中定义的接口直接转换成 C 语言的接口，并利用 NodeJS 的 Buffer 内存，将其同载入的 DLL 共享。当然由于 FFI 的这种通用性，也导致了一定的性能损失。&lt;/p&gt;
&lt;p&gt;下面就以在 Windows 平台上使用 FFI 为例，简单聊一下如何使用 NodeJS 和 C++编译而成的 DLL 通信吧。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.zhengi.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="NodeJS" scheme="https://blog.zhengi.me/categories/%E6%8A%80%E6%9C%AF/NodeJS/"/>
    
    
    <category term="C++" scheme="https://blog.zhengi.me/tags/C/"/>
    
    <category term="NodeJS" scheme="https://blog.zhengi.me/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>简谈C++中指针与引用的底层实现</title>
    <link href="https://blog.zhengi.me/a_brief_talk_about_pointer_and_reference/"/>
    <id>https://blog.zhengi.me/a_brief_talk_about_pointer_and_reference/</id>
    <published>2019-09-11T12:52:24.000Z</published>
    <updated>2024-03-23T06:03:16.943Z</updated>
    
    <content type="html"><![CDATA[<p>引用是C++相对于C而引入的一个重要特性，它使得许多地方的语法变得更加简洁，但是它们的底层究竟是怎么实现的呢？</p><p>在Wikipedia中，对指针有如下介绍：</p><blockquote><p>In computer science, a pointer is a programming language object that stores the memory address of another value located in computer memory. A pointer references a location in memory, and obtaining the value stored at that location is known as dereferencing the pointer.</p></blockquote><p>从定义可以看出，指针从本质上来讲就是一个变量，其中所存储的就是其他变量的地址。 而C语言中的指针非常灵活，它可以任意指向某一个地址，不论这个地址究竟是否存在，或它究竟存储的是否为指针所代表类型的数据。</p><p>那么也不难想到，指针在实现的时候也是内存里的一个变量，它存有其他变量的地址。</p><p>在Wikipedia中，对引用有如下介绍：</p><blockquote><p>In computer science, a reference is a value that enables a program to indirectly access a particular datum, such as a variable’s value or a record, in the computer’s memory or in some other storage device. The reference is said to refer to the datum, and accessing the datum is called dereferencing the reference.</p><p>In the C++ programming language, a reference is a simple reference datatype that is less powerful but safer than the pointer type inherited from C. The name C++ reference may cause confusion, as in computer science a reference is a general concept datatype, with pointers and C++ references being specific reference datatype implementations. The definition of a reference in C++ is such that it does not need to exist. It can be implemented as a new name for an existing object (similar to rename keyword in Ada). </p></blockquote><p>从上面的定义可以看出，在C++中，引用可以狭义地认为是某一个变量的别名，它本身是并不存在的。</p><span id="more"></span><p>基于以上说法，我就一度认为引用只是C++编译器在编译时的一些黑魔法，它在运行的时候将两个解析到的符号链接成了一个，从而完成了引用，而在编译之后，引用与本体就是一个变量（一个寄存器或栈上的值）。</p><p>但是,事实却打了我的脸。</p><p>我们通过以下程序进行检验：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *pa = &amp;a;</span><br><span class="line">    <span class="type">int</span> &amp;ra = a;</span><br><span class="line">    ++(*pa);</span><br><span class="line">    ++ra;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序声明了一个变量a，然后分别声明指针pa指向a的地址，生命引用ra指向a，最后分别使用指针和地址对a进行了一次自加操作。</p><p>接下来，使用<code>gcc -S test.cpp -o test.s -O0</code>将上面的C++程序编译为汇编，看一下这些操作具体都是怎么实现的。(环境为MacOS，LLVM 10.0.1)</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.section</span>__TEXT,__text,regular,pure_instructions</span><br><span class="line"><span class="meta">.build_version</span> macos, <span class="number">10</span>, <span class="number">14</span>sdk_version <span class="number">10</span>, <span class="number">14</span></span><br><span class="line"><span class="meta">.globl</span>_main                   ## -- Begin function main</span><br><span class="line"><span class="meta">.p2align</span><span class="number">4</span>, <span class="number">0x90</span></span><br><span class="line"><span class="symbol">_main:</span>                                  ## @main</span><br><span class="line"><span class="meta">.cfi_startproc</span></span><br><span class="line">## %bb<span class="number">.0</span>:</span><br><span class="line"><span class="comment">; 保护现场</span></span><br><span class="line">pushq%rbp</span><br><span class="line"><span class="meta">.cfi_def_cfa_offset</span> <span class="number">16</span></span><br><span class="line"><span class="meta">.cfi_offset</span> %rbp, -<span class="number">16</span></span><br><span class="line"><span class="comment">; 保存栈指针</span></span><br><span class="line"><span class="keyword">movq</span>%rsp, %rbp</span><br><span class="line"><span class="meta">.cfi_def_cfa_register</span> %rbp</span><br><span class="line"><span class="comment">; 设置返回值为0</span></span><br><span class="line">xorl%eax, %eax</span><br><span class="line"><span class="comment">; int a = 0</span></span><br><span class="line">movl<span class="number">$0</span>, -<span class="number">4</span>(%rbp)</span><br><span class="line"><span class="comment">; t0 = &amp;a</span></span><br><span class="line">leaq-<span class="number">4</span>(%rbp), %rcx</span><br><span class="line"><span class="comment">; int *pa = t0</span></span><br><span class="line"><span class="keyword">movq</span>%rcx, -<span class="number">16</span>(%rbp)</span><br><span class="line"><span class="comment">; int &amp;ra = t0</span></span><br><span class="line"><span class="keyword">movq</span>%rcx, -<span class="number">24</span>(%rbp)</span><br><span class="line"><span class="comment">; t0 = pa</span></span><br><span class="line"><span class="keyword">movq</span>-<span class="number">16</span>(%rbp), %rcx</span><br><span class="line"><span class="comment">; t1 = *t0 = *pa</span></span><br><span class="line">movl(%rcx), %edx</span><br><span class="line"><span class="comment">; ++t1</span></span><br><span class="line">addl<span class="number">$1</span>, %edx</span><br><span class="line"><span class="comment">; *t0 = *pa = t1</span></span><br><span class="line">movl%edx, (%rcx)</span><br><span class="line"><span class="comment">; t0 = &amp;ra = &amp;a</span></span><br><span class="line"><span class="keyword">movq</span>-<span class="number">24</span>(%rbp), %rcx</span><br><span class="line"><span class="comment">; t1 = *t0 = *(&amp;ra) = ra = a</span></span><br><span class="line">movl(%rcx), %edx</span><br><span class="line"><span class="comment">; ++t1</span></span><br><span class="line">addl<span class="number">$1</span>, %edx</span><br><span class="line"><span class="comment">; *t0 = *(&amp;ra) = ra = a = t1</span></span><br><span class="line">movl%edx, (%rcx)</span><br><span class="line"><span class="comment">; 恢复现场</span></span><br><span class="line">popq%rbp</span><br><span class="line"><span class="comment">; 返回</span></span><br><span class="line">retq</span><br><span class="line"><span class="meta">.cfi_endproc</span></span><br><span class="line">                                        ## -- End function</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">.subsections_via_symbols</span></span><br></pre></td></tr></table></figure><p>我已经将汇编中的关键代码加上了注释，可以看出，变量a，指针pa，以及引用ra都位于栈上，index分别在-4、-16、-24。需要注意的是，引用并不是直接复用了变量a的<code>-4(%rbp)</code>地址，而是像指针一样，使用了一个新地址，并且将leaq计算得到的a的地址写入了其中。</p><p>而在进行自加的时候，除了最开始将指针中的内容拷贝到寄存器中所用的地址不同以外，指针和引用所使用的方式是完全相同的。</p><p>这个结果令我非常意外，<em>编译器其实是将开发者对引用的操作翻译成了对指针的操作</em>。</p><p>最后，发现现代编译器还是很聪明的，如果将优化级别调到更高，就会发现它直接将中间的计算过程全部简化，直接返回，这是因为计算结果并没有任何输出，它是不必要的。如果将上面的代码从main函数转移到其他函数中，编译器这时虽然不能放弃计算其中的数值，但还是做了尽力的优化，直接返回结果（<code>movl    $2, %eax</code>）。</p><h1 id="进一步的实验"><a href="#进一步的实验" class="headerlink" title="进一步的实验"></a>进一步的实验</h1><p>在文章发出后，有同学提出了质疑，认为可能只是MacOS上gcc编译器的特定操作，并不具有普适性，所以我在Linux和Windows上重复了上述实验。</p><p>在Linux环境中（发行版为Ubuntu 18.04，gcc版本为7.5.0）使用相同指令编译后得到的汇编码如下所示：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.file</span><span class="string">&quot;test_ref.cpp&quot;</span></span><br><span class="line"><span class="meta">.text</span></span><br><span class="line"><span class="meta">.globl</span>main</span><br><span class="line"><span class="meta">.type</span>main, @function</span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line"><span class="symbol">.LFB0:</span></span><br><span class="line"><span class="meta">.cfi_startproc</span></span><br><span class="line"><span class="comment">; 保护现场</span></span><br><span class="line">pushq%rbp</span><br><span class="line"><span class="meta">.cfi_def_cfa_offset</span> <span class="number">16</span></span><br><span class="line"><span class="meta">.cfi_offset</span> <span class="number">6</span>, -<span class="number">16</span></span><br><span class="line"><span class="comment">; 保存栈指针</span></span><br><span class="line"><span class="keyword">movq</span>%rsp, %rbp</span><br><span class="line"><span class="meta">.cfi_def_cfa_register</span> <span class="number">6</span></span><br><span class="line">subq<span class="number">$32</span>, %rsp</span><br><span class="line"><span class="keyword">movq</span>%fs:<span class="number">40</span>, %rax</span><br><span class="line"><span class="keyword">movq</span>%rax, -<span class="number">8</span>(%rbp)</span><br><span class="line"><span class="comment">; 设置返回值为0</span></span><br><span class="line">xorl%eax, %eax</span><br><span class="line"><span class="comment">; int a = 0</span></span><br><span class="line">movl<span class="number">$0</span>, -<span class="number">28</span>(%rbp)</span><br><span class="line"><span class="comment">; t0 = &amp;a</span></span><br><span class="line">leaq-<span class="number">28</span>(%rbp), %rax</span><br><span class="line"><span class="comment">; int *pa = t0</span></span><br><span class="line"><span class="keyword">movq</span>%rax, -<span class="number">24</span>(%rbp)</span><br><span class="line"><span class="comment">; t0 = &amp;a</span></span><br><span class="line">leaq-<span class="number">28</span>(%rbp), %rax</span><br><span class="line"><span class="comment">; int &amp;ra = t0</span></span><br><span class="line"><span class="keyword">movq</span>%rax, -<span class="number">16</span>(%rbp)</span><br><span class="line"><span class="comment">; t0 = pa</span></span><br><span class="line"><span class="keyword">movq</span>-<span class="number">24</span>(%rbp), %rax</span><br><span class="line"><span class="comment">; t1 = *t0 = *pa</span></span><br><span class="line">movl(%rax), %eax</span><br><span class="line"><span class="comment">; t2 = *t0 + 1</span></span><br><span class="line">leal<span class="number">1</span>(%rax), %edx</span><br><span class="line"><span class="comment">; t0 = pa</span></span><br><span class="line"><span class="keyword">movq</span>-<span class="number">24</span>(%rbp), %rax</span><br><span class="line"><span class="comment">; *t0 = *pa = t2 = *t0 + 1</span></span><br><span class="line">movl%edx, (%rax)</span><br><span class="line"><span class="comment">; t0 = ra</span></span><br><span class="line"><span class="keyword">movq</span>-<span class="number">16</span>(%rbp), %rax</span><br><span class="line"><span class="comment">; t1 = *t0 = *pa</span></span><br><span class="line">movl(%rax), %eax</span><br><span class="line"><span class="comment">; t2 = *t0 + 1</span></span><br><span class="line">leal<span class="number">1</span>(%rax), %edx</span><br><span class="line"><span class="comment">; t0 = ra</span></span><br><span class="line"><span class="keyword">movq</span>-<span class="number">16</span>(%rbp), %rax</span><br><span class="line"><span class="comment">; *t0 = *ra = t2 = *t0 + 1</span></span><br><span class="line">movl%edx, (%rax)</span><br><span class="line"><span class="comment">; 返回值设置为0</span></span><br><span class="line">movl<span class="number">$0</span>, %eax</span><br><span class="line"><span class="keyword">movq</span>-<span class="number">8</span>(%rbp), %rcx</span><br><span class="line">xorq%fs:<span class="number">40</span>, %rcx</span><br><span class="line"><span class="keyword">je</span>.L3</span><br><span class="line"><span class="keyword">call</span>__stack_chk_fail@PLT</span><br><span class="line"><span class="symbol">.L3:</span></span><br><span class="line"><span class="keyword">leave</span></span><br><span class="line"><span class="meta">.cfi_def_cfa</span> <span class="number">7</span>, <span class="number">8</span></span><br><span class="line"><span class="keyword">ret</span></span><br><span class="line"><span class="meta">.cfi_endproc</span></span><br><span class="line"><span class="symbol">.LFE0:</span></span><br><span class="line"><span class="meta">.size</span>main, .-main</span><br><span class="line"><span class="meta">.ident</span><span class="string">&quot;GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0&quot;</span></span><br><span class="line"><span class="meta">.section</span>.note<span class="number">.</span>GNU-stack,<span class="string">&quot;&quot;</span>,@progbits</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看出与MacOS中gcc的编译结果基本相同。</p><p>在Windows环境中（Windows 10，vs2019，cl版本为19.23.28106.4），可以使用命令<code>cl /Od /FA .\test_ref.cpp</code>对源码进行编译，可以得到汇编代码如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; Listing generated by Microsoft (R) Optimizing Compiler Version 19.23.28106.4 </span></span><br><span class="line"></span><br><span class="line">TITLEC:\Users\jason\<span class="keyword">test</span>\test_ref<span class="number">.</span>cpp</span><br><span class="line"><span class="meta">.686P</span></span><br><span class="line"><span class="meta">.XMM</span></span><br><span class="line">include listing<span class="number">.</span><span class="keyword">inc</span></span><br><span class="line"><span class="meta">.model</span>flat</span><br><span class="line"></span><br><span class="line">INCLUDELIB LIBCMT</span><br><span class="line">INCLUDELIB OLDNAMES</span><br><span class="line"></span><br><span class="line"><span class="meta">PUBLIC</span>_main</span><br><span class="line"><span class="comment">; Function compile flags: /Odtp</span></span><br><span class="line">_TEXT<span class="meta">SEGMENT</span></span><br><span class="line">_ra$ = -<span class="number">12</span><span class="comment">; size = 4</span></span><br><span class="line">_pa$ = -<span class="number">8</span><span class="comment">; size = 4</span></span><br><span class="line">_a$ = -<span class="number">4</span><span class="comment">; size = 4</span></span><br><span class="line">_mainPROC</span><br><span class="line"><span class="comment">; File C:\Users\jason\test\test_ref.cpp</span></span><br><span class="line"><span class="comment">; Line 2</span></span><br><span class="line"><span class="keyword">push</span><span class="built_in">ebp</span></span><br><span class="line"><span class="keyword">mov</span><span class="built_in">ebp</span>, <span class="built_in">esp</span></span><br><span class="line"><span class="keyword">sub</span><span class="built_in">esp</span>, <span class="number">12</span><span class="comment">; 0000000cH</span></span><br><span class="line"><span class="comment">; Line 3</span></span><br><span class="line"><span class="keyword">mov</span><span class="built_in">DWORD</span> <span class="built_in">PTR</span> _a$[<span class="built_in">ebp</span>], <span class="number">0</span></span><br><span class="line"><span class="comment">; Line 4</span></span><br><span class="line"><span class="keyword">lea</span><span class="built_in">eax</span>, <span class="built_in">DWORD</span> <span class="built_in">PTR</span> _a$[<span class="built_in">ebp</span>]</span><br><span class="line"><span class="keyword">mov</span><span class="built_in">DWORD</span> <span class="built_in">PTR</span> _pa$[<span class="built_in">ebp</span>], <span class="built_in">eax</span></span><br><span class="line"><span class="comment">; Line 5</span></span><br><span class="line"><span class="keyword">lea</span><span class="built_in">ecx</span>, <span class="built_in">DWORD</span> <span class="built_in">PTR</span> _a$[<span class="built_in">ebp</span>]</span><br><span class="line"><span class="keyword">mov</span><span class="built_in">DWORD</span> <span class="built_in">PTR</span> _ra$[<span class="built_in">ebp</span>], <span class="built_in">ecx</span></span><br><span class="line"><span class="comment">; Line 6</span></span><br><span class="line"><span class="keyword">mov</span><span class="built_in">edx</span>, <span class="built_in">DWORD</span> <span class="built_in">PTR</span> _pa$[<span class="built_in">ebp</span>]</span><br><span class="line"><span class="keyword">mov</span><span class="built_in">eax</span>, <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">edx</span>]</span><br><span class="line"><span class="keyword">add</span><span class="built_in">eax</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">mov</span><span class="built_in">ecx</span>, <span class="built_in">DWORD</span> <span class="built_in">PTR</span> _pa$[<span class="built_in">ebp</span>]</span><br><span class="line"><span class="keyword">mov</span><span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ecx</span>], <span class="built_in">eax</span></span><br><span class="line"><span class="comment">; Line 7</span></span><br><span class="line"><span class="keyword">mov</span><span class="built_in">edx</span>, <span class="built_in">DWORD</span> <span class="built_in">PTR</span> _ra$[<span class="built_in">ebp</span>]</span><br><span class="line"><span class="keyword">mov</span><span class="built_in">eax</span>, <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">edx</span>]</span><br><span class="line"><span class="keyword">add</span><span class="built_in">eax</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">mov</span><span class="built_in">ecx</span>, <span class="built_in">DWORD</span> <span class="built_in">PTR</span> _ra$[<span class="built_in">ebp</span>]</span><br><span class="line"><span class="keyword">mov</span><span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ecx</span>], <span class="built_in">eax</span></span><br><span class="line"><span class="comment">; Line 8</span></span><br><span class="line"><span class="keyword">xor</span><span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line"><span class="keyword">mov</span><span class="built_in">esp</span>, <span class="built_in">ebp</span></span><br><span class="line"><span class="keyword">pop</span><span class="built_in">ebp</span></span><br><span class="line"><span class="keyword">ret</span><span class="number">0</span></span><br><span class="line">_mainENDP</span><br><span class="line">_TEXTENDS</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>cl编译器的汇编代码格式和gcc略有不同，但含义相近，并且可以比较轻易地通过上面标出的代码行数确定汇编代码的含义。可以看出，它使用的方法也和前两种相同。</p><p>这里再进一步，引入知乎上“XZiar”同学的评论，她的评论更加深入地理解其中的机制：</p><blockquote><p>其实不是说“把引用解释成指针”吧。</p><p>在机器码层面，也不存在指针，只存在地址（指针其实还隐含了类型信息）。变量这个概念也是不存在的，只有“无格式数据”，被带格式的指令操作而已。</p><p>所以你看到引用和指针的效果一样，是因为在机器码层面，没有多余的信息去表明他们的区别了。</p><p>而在语言层面，引用的确可以理解为const指针</p></blockquote><p>另外，她针对为什么汇编代码中引用把地址复制了一遍也进行了更深入的解释：</p><blockquote><p>另外引用把地址复制一遍也是很正常的，编译器也的确没法在编译期完全分析出引用的具体指向。考虑如下代码：</p><p>int a=0,b=1; int&amp; c = flag ? a : b;</p><p>引用只不过因为const所以不能被重置，但具体指向什么，是可以运行期决定的。</p></blockquote><p>到这里，对于指针和引用底层实现的探索也基本结束了，可以看出，在不启用编译器优化的情况下，主流编译器都会选择将C++中的引用解释为“const指针”。</p><p>但是，如果在启动编译器优化的情况下会是如何呢？在MacOS中，将源代码中的返回值改为a后（为了防止编译器优化后认为没有输出于是什么都不做），同时将编译器优化选项调整为O1和O2，其结果是相同的，如下所示：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.section</span>__TEXT,__text,regular,pure_instructions</span><br><span class="line"><span class="meta">.build_version</span> macos, <span class="number">10</span>, <span class="number">15</span>sdk_version <span class="number">10</span>, <span class="number">15</span>, <span class="number">4</span></span><br><span class="line"><span class="meta">.globl</span>_main                   ## -- Begin function main</span><br><span class="line"><span class="meta">.p2align</span><span class="number">4</span>, <span class="number">0x90</span></span><br><span class="line"><span class="symbol">_main:</span>                                  ## @main</span><br><span class="line"><span class="meta">.cfi_startproc</span></span><br><span class="line">## %bb<span class="number">.0</span>:</span><br><span class="line">pushq%rbp</span><br><span class="line"><span class="meta">.cfi_def_cfa_offset</span> <span class="number">16</span></span><br><span class="line"><span class="meta">.cfi_offset</span> %rbp, -<span class="number">16</span></span><br><span class="line"><span class="keyword">movq</span>%rsp, %rbp</span><br><span class="line"><span class="meta">.cfi_def_cfa_register</span> %rbp</span><br><span class="line">movl<span class="number">$2</span>, %eax</span><br><span class="line">popq%rbp</span><br><span class="line">retq</span><br><span class="line"><span class="meta">.cfi_endproc</span></span><br><span class="line">                                        ## -- End function</span><br></pre></td></tr></table></figure><p>可以看出汇编版本的代码中省略了所有和指针、引用及内存操作相关的代码，直接将返回值设置为2。</p><p>从这里可以看出，编译器的作用是将语言编写的代码翻译为合理的汇编代码，只要汇编代码可以源代码的真实意图执行即可。由于机器码可以表达的概念有限（基本上就是对于寄存器和内存的运算），而高级语言可以表达的概念十分多样，所以编译器就需要将高级语言中的各种复杂概念映射（也可以看做是翻译）为机器码中的简单概念，映射的过程可能会有多种方案，其最终选择是由编译器来决定的。在C++指针和引用的翻译中，主流的C++编译器都选择将它们映射为机器码中的地址，而舍弃了其中的类型信息。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引用是C++相对于C而引入的一个重要特性，它使得许多地方的语法变得更加简洁，但是它们的底层究竟是怎么实现的呢？&lt;/p&gt;
&lt;p&gt;在Wikipedia中，对指针有如下介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In computer science, a pointer is a programming language object that stores the memory address of another value located in computer memory. A pointer references a location in memory, and obtaining the value stored at that location is known as dereferencing the pointer.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从定义可以看出，指针从本质上来讲就是一个变量，其中所存储的就是其他变量的地址。 而C语言中的指针非常灵活，它可以任意指向某一个地址，不论这个地址究竟是否存在，或它究竟存储的是否为指针所代表类型的数据。&lt;/p&gt;
&lt;p&gt;那么也不难想到，指针在实现的时候也是内存里的一个变量，它存有其他变量的地址。&lt;/p&gt;
&lt;p&gt;在Wikipedia中，对引用有如下介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In computer science, a reference is a value that enables a program to indirectly access a particular datum, such as a variable’s value or a record, in the computer’s memory or in some other storage device. The reference is said to refer to the datum, and accessing the datum is called dereferencing the reference.&lt;/p&gt;
&lt;p&gt;In the C++ programming language, a reference is a simple reference datatype that is less powerful but safer than the pointer type inherited from C. The name C++ reference may cause confusion, as in computer science a reference is a general concept datatype, with pointers and C++ references being specific reference datatype implementations. The definition of a reference in C++ is such that it does not need to exist. It can be implemented as a new name for an existing object (similar to rename keyword in Ada). &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从上面的定义可以看出，在C++中，引用可以狭义地认为是某一个变量的别名，它本身是并不存在的。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.zhengi.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="C++" scheme="https://blog.zhengi.me/categories/%E6%8A%80%E6%9C%AF/C/"/>
    
    
    <category term="C++" scheme="https://blog.zhengi.me/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>流浪地球——中国科幻电影的开章</title>
    <link href="https://blog.zhengi.me/the_wandering_earch_the_genesis_of_chinese_fiction/"/>
    <id>https://blog.zhengi.me/the_wandering_earch_the_genesis_of_chinese_fiction/</id>
    <published>2019-02-08T05:06:33.000Z</published>
    <updated>2024-03-23T06:03:16.947Z</updated>
    
    <content type="html"><![CDATA[<p>自昨天下午看完《流浪地球》以后，内心久久难以平静。闭上眼睛后，大脑中出现的是流浪地球的主题曲《带着地球去流浪》和地球飞临木星时候大气交汇时那种磅礴而又难以用语言形容的场景。</p><p>这首歌里，一面是曹操的《观沧海》，描述了人类面对这个世界所发出的赞叹，描述出了大好河山的雄伟壮丽。而另一方面，又进行了古今对比，更体现出这场星际旅行的悲凉与无奈。伴着这首歌，我就知道必须要写些什么了。</p><span id="more"></span><iframe border="0" marginwidth="0" marginheight="0" src="//music.163.com/outchain/player?type=2&id=1341939931&auto=1&height=66" width="380" height="80" frameborder="no"></iframe>（如果不能播放可以点击[这里](http://music.163.com/#/m/song?id=1341939931)跳入网易云音乐播放）<h1 id="回忆"><a href="#回忆" class="headerlink" title="回忆"></a>回忆</h1><p>不知不觉，我进入了一段回忆，我可能是在想我是如何与科幻结缘，我又是对《流浪地球》有着怎样的期盼。</p><p>第一次开始对太空和空间科学感兴趣，是源于小学时候在 Windows98 电脑中的一个太空主题。我的印象很深，它的屏幕背景是由一个宇航员和一个太空站构成。桌面上的图标都被改成了星球的样子，而屏幕保护更是让宇航员和太空站动了起来。我在网上找到了一个动图：</p><p><a href="/images/posts/the_wandering_earch_the_genesis_of_chinese_fiction/windows_98_space.gif"><img data-src="/images/posts/the_wandering_earch_the_genesis_of_chinese_fiction/windows_98_space.gif"></a></p><p>每次从老旧的 CRT 显示器中看到这个桌面，我就仿佛置身于浩瀚缥缈的宇宙之中，一面是我所向往的科学殿堂，另一面是置身于宇宙中的无穷之美。</p><p>之后，大概是很多年之后，我逐渐对物理学有了很深的兴趣，痴迷于《果壳中的宇宙》和《时间简史》中描述的宇宙的本质、宇宙的演变和宇宙的图景。</p><p>另一方面，我也开始对科幻电影感兴趣，看了许多有有关于宇宙的科幻的电影：《星际穿越》、《星际迷航》、《地心引力》、《月球》、《火星救援》、等等等等。《星际穿越》中那个空旷无比的全景宇宙，以及在宇宙中硕大无比（像 IE 图标一样）的黑洞，一再地震撼着我的心灵。</p><p><a href="/images/posts/the_wandering_earch_the_genesis_of_chinese_fiction/Interstellar_black_hole.jpg"><img data-src="/images/posts/the_wandering_earch_the_genesis_of_chinese_fiction/Interstellar_black_hole.jpg"></a></p><p>再之后，就是接触到了《三体》的时候，那种激动到在期中考试前一天晚上彻夜阅读的心情，到现在都难以忘记。在看完三体以后，大呼过瘾，所以我又接二连三地去读大刘的其他作品。《球星闪电》、《流浪地球》、《乡村教师》、《赡养上帝》，这些都是读过就很难忘记的好作品。</p><p>而在前几年我又听到《三体》已经开机的声音，当时的心情是忐忑大于期望，我很担心这么宏伟的一个科幻世界被电影给毁掉，都不如 B 站 UP 主文曰小强用别的电影剪辑出的<a href="https://www.bilibili.com/video/av8370807">《速读三体》</a>耐看。好在最后电影流产，我长舒一口气。</p><p>同样，在去年夏天首次听到《流浪地球》即将上映的时候我又是捏了一把汗。直到去年下半年来，随着电影的预告片一部一部地放出，以及看过电影的人对电影的评价都趋于正面，而且还有大刘作为监制，吴京也宣布加盟，我的心态逐渐从揪心转为期待。</p><p>随着主题曲《带着地球去流浪》及 <a href="https://music.163.com/#/mv?id=10850278">其 MV</a> 的放出，我对电影的画面彻底放心了，唯一的悬念就是剧情。</p><h1 id="说回电影"><a href="#说回电影" class="headerlink" title="说回电影"></a>说回电影</h1><p>回忆告一段落，现在就分几个维度来说说我对电影的感受。</p><h2 id="视觉效果"><a href="#视觉效果" class="headerlink" title="视觉效果"></a>视觉效果</h2><p>从预告片到正片里的几乎所有视觉效果，都完完全全地震撼到了我，放眼其它国产片的特效，和《流浪地球》相比，无出其右。在我的感观中，电影已经达到了好莱坞的水准。</p><p>特别是在电影中看见地球的大气被木星捕获时候的画面。一方面，地球发动机喷射出淡蓝色的粒子流，另一方面，地球的大气又和木星的大气进行了交融。那时我才真的感受到木星和地球体积的对比。我想，站在地球上，看见如此庞大的一个星球完全占据了整个天空，那种压抑感、对无尽和死亡的恐惧以及在得知地球即将解体的消息后的无助是难以言表的，只借助用这样的画面呈现出来。</p><p><a href="/images/posts/the_wandering_earch_the_genesis_of_chinese_fiction/earth_and_jupiter.png"><img data-src="/images/posts/the_wandering_earch_the_genesis_of_chinese_fiction/earth_and_jupiter.png"></a></p><p>另一个让我感到很震撼的画面是电影开始时候，镜头从车队的特写一直向上拉动，到了华北平原，又到了行星发动机，最后到了宇宙上空的领航者号空间站。每一个画面中都充斥着那种苏联式的巨型机械感，让我非常兴奋。</p><p><a href="/images/posts/the_wandering_earch_the_genesis_of_chinese_fiction/frame_in_movie.png"><img data-src="/images/posts/the_wandering_earch_the_genesis_of_chinese_fiction/frame_in_movie.png"></a></p><p>其实这里的画面又让我有了一些游戏感，很像《红色警戒》2 或者 3 中雪天场景中的苏联。有一阵儿对红警入迷很深，做梦梦到的都是里面的场景，和电影中的十分相似。所以看到这里，让我十分惊诧，没想到梦中的画面居然在这部电影中被看到了。特别地，在最后刘启赶往苏拉威西转向发动机的时候，他的车子开入一个底座，然后底座开始旋转，这不就是红警 3 中的矿车嘛！</p><h2 id="剧情"><a href="#剧情" class="headerlink" title="剧情"></a>剧情</h2><p>不得不说，大刘给流浪地球所设定的如此宏大的世界观给了电影很大的发挥空间。电影中的这一段地木相会在书中花了可能不到一页的笔墨。但是通过合理的剧情拓展，已经可以撑得起一部电影了（甚至还因为控制时间被剪辑掉了一部分）。</p><p>可能就是受到剪辑的影响，电影前一小段的剧情进展太快，很多事情都没有交代。比如刘启为何要离家出走，妹妹为何也想出去看看，这些年为何父子产生了这么大的矛盾，都没有交代清楚。有些剧情虽然可以脑补，但是多少会让人在现场的时候感到疑惑或者是突兀。不过，从他们兄妹两人踏出地下城电梯门的那一刹那，一切节奏都恢复了正常。</p><p>而剧情中令人印象最深的不是抢救火种，不是太空行走，也不是重启发动机，而是运载车启动时不断重复的那几句话：“道路千万条，安全第一条；行车不规范，亲人两行泪。”由于其严重的不押韵，一度让我听得百爪挠心。但是随着剧情的推进，这句话也逐渐融入了更多的情感，特别是在“姥爷”变成“冰雕”之后，在听见这句话，已经是对“老东西”的那种怀念。</p><p>另外，在电影最后还给了一个很大的彩蛋。透过主角的视角，可以看见地下城中有人喊着“还我阳光”的口号在进行游行。我立刻就想到原著中反派认为流浪地球计划是一个谎言，于是发生暴乱，占领了地球发动机的中控室，并将流浪地球计划的领导人都执行了最冷酷的“冻刑”。这是不是说明之后还会有《流浪地球 2》上映呢，内心又燃起了很强的期待。</p><h2 id="一些有趣的点"><a href="#一些有趣的点" class="headerlink" title="一些有趣的点"></a>一些有趣的点</h2><p>整场电影都的基调都非常刘慈欣，在电影中，集体主义和生存主义被体现的淋漓尽致。比如，在地球停止自转后，地球上的人口锐减了一半（这不就是灭霸嘛），而进入地下城也需要抽签决定，如果没有抽到签，在地表的冰天雪地中能够存活下来的人怕是寥寥无几。但是电影有正当的理由——为了更多人，为了整个人类的生存，必须这样做。这种做法对于自由、平等、博爱所建立的西方价值观是一个颠覆，许多人怕是也无法接受这样的设定。</p><p>是的，我们会为了大多数人以及我们的子孙后代牺牲另一部分人。但是，如果按照好莱坞的套路，最后不会选择带着地球离开，而是带着人类文明的种子（也就是火种计划）离开。这样，活下来的可能就不是地球上的数万万人，而是领航者号空间站上的这些人。这样就人人平等了么？文明得以延续的基础是整个人类的大社会。如果只剩下空间站上的这些人，在他们离开的那一天，可能就已经不是人类了。</p><p>第二个是真实，非常的真实。在救援队试图借助电梯从峡谷中向上方运送火石的时候，一个队员为了救爷爷，被掉下的电梯活活砸死，而爷爷却也在被救后的几分钟内，因为衣服漏气，导致氧气消耗殆尽，最后自行解开头盔，成为了一座冰雕。队员的死并没有换来爷爷的活，而爷爷的死也并没有激发刘启“拯救人类”的斗志。这样的例子还有很多，比如随处可见送火种的人成为了冰雕。他们的死亡都几乎是没有任何意义的。电影脱离了必须要给死亡安上一个意义的俗套，也没有了失去了什么必定会得到什么的“真理”，让观影体验更加的真实。</p><p>另一个有意思的地方是“饱和式救援”。着同样也超越了西方模式化的超级英雄电影。</p><p>在那一类的电影中，一定是主角与家人不和，然后出走，之后是众人皆醉我独醒，发现了一个惊天的秘密，但大家并不理解他，除了他的几个好朋友。于是他叫上了他的好朋友，开始闯关似的拯救世界。最后，他凭借一己之力，扭转了局势，拯救了世界，并且还一不小心收获了爱情。</p><p>但是在人类生死存亡的关键时刻，哪有人敢怠慢。行星发动机的是全人类最后的希望，必须全力以赴。所以人类派出了远远超过发动机数量的团队，征召了所有可用的力量，来修复每个行星发动机。比如在主角们赶向苏拉威西发动机的时候，就已经有人提前到达，并成功重启了发动机；而主角们想到要点燃火星的时候，也被告知以色列的团队也已经早在几个小时前想到了这个方案，等等。这才是认了里面对灾难应该有的状态，而不是靠着主角团一路开挂，就拯救了全人类。英雄们是存在的，但不只有一个。</p><h2 id="一些比较吐槽的点"><a href="#一些比较吐槽的点" class="headerlink" title="一些比较吐槽的点"></a>一些比较吐槽的点</h2><p>首先，情节太过单薄的问题已经在上面说过了，这可能是因为剪辑的原因，希望以后可以看到完整版的电影。</p><p>其次就是最后用木星爆炸的冲击力来推离地球的设定，让我突然有一种“这个地方有点假吧”的出戏感。因为大概想一想，靠化学能量的非定向爆炸来将地球从如此大的一个引力场推走，是一个多么不靠谱的决定。不过科幻也总是包含很多幻想的成分，在没有更好的方案的情况下，我表示理解。</p><p>另一个是主题升华的问题。电影中一直表现出的是父亲对孩子的爱，但是却没有升华到对于地球上的人类，以及对于子孙后代的爱上。这样很容易让人感到父亲开着空间站去点燃木星是因为要救他的孩子，顺便拯救了全人类。这样就让我去思考到父亲在空间站中的决策是自私还是博爱，以牺牲“火种计划”为代价来换取概率几乎为 0 的成功是否值得。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>总的来说，《流浪地球》给中国科幻电影做了一个好的榜样，希望以后可以有更多类似的好电影上映。</p><p>“啊，地球，我的流浪地球啊！”</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;自昨天下午看完《流浪地球》以后，内心久久难以平静。闭上眼睛后，大脑中出现的是流浪地球的主题曲《带着地球去流浪》和地球飞临木星时候大气交汇时那种磅礴而又难以用语言形容的场景。&lt;/p&gt;
&lt;p&gt;这首歌里，一面是曹操的《观沧海》，描述了人类面对这个世界所发出的赞叹，描述出了大好河山的雄伟壮丽。而另一方面，又进行了古今对比，更体现出这场星际旅行的悲凉与无奈。伴着这首歌，我就知道必须要写些什么了。&lt;/p&gt;</summary>
    
    
    
    <category term="影评" scheme="https://blog.zhengi.me/categories/%E5%BD%B1%E8%AF%84/"/>
    
    
    <category term="影评" scheme="https://blog.zhengi.me/tags/%E5%BD%B1%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>2018 年终总结</title>
    <link href="https://blog.zhengi.me/year_summary_2018/"/>
    <id>https://blog.zhengi.me/year_summary_2018/</id>
    <published>2018-12-30T07:06:54.000Z</published>
    <updated>2024-03-23T06:03:16.947Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>倏忽之间，又过去了一年。是时候向 2018 说一声再见了。</p><p>今年，我只在写 <a href="/feelings_around_new_year">年关随笔</a> 时立了一个 Flag，要练习深度写作，至少每个月输出一篇文章。可惜因为暑假时候偷懒，这个 Flag 也并没有达成。不过，我还是要在 2019 重新立起这样一个 Flag —— 2019 年每个月至少输出一篇文章，可以是技术，可以是随笔，也可以是观点。希望明年这个时候再回来看，不要像今年一样打脸。</p><p>再说回 2018。这一年相比前些年，在我的努力下，节奏逐渐慢了下来，让我有了许多时间静下心来思考、做事，也有时间和爱人相处、与朋友侃大山（至少在十一月之前是这样的）。同时，这一年又并不像以往那么顺遂，让我明白了人力有限，世间有太多力所不能及之事。</p><h1 id="时光·记忆"><a href="#时光·记忆" class="headerlink" title="时光·记忆"></a>时光·记忆</h1><p>在大自然面前，没有什么是能够永恒的。人不能够，事不能够，城也不能够，甚至文明也不能够。</p><span id="more"></span><p>在奶奶走后，我每每做梦都会回到小时候，梦见亲人们都在，他们都能和谐相处；梦见家乡没有衰败，还有很多人居住；梦见我很强，能够办到一切事情。</p><p>可惜梦中和现实却每每都是相反的。我无力改变太多，但至少可以做些什么。眼下能做的事情，就是把家乡的景，家乡的事儿多记录一些，等多年后，这里变成一片荒山野岭，无人问津的时候，人们还是能从我只字片语的记录之中，知道有这样一个地方，曾经有这样一批人，为了祖国的建设，把最好的青春和无尽的才华都奉献在这西北的茫茫荒山之中。</p><p>我在这里贴上几张年初所拍的照片吧。</p><p>这两张是白银市老城区白天和晚上的景观，拍摄于白银市人民医院综合楼楼顶。白银市从今年开始增加了许多城市亮化的工程，在白天看来就是一个暮气沉沉的工业老城，但是在晚上看来尤其漂亮。</p><p><a href="/images/posts/year_summary_2018/photo-baiyin-884-3.jpg"><img data-src="/images/posts/year_summary_2018/photo-baiyin-884-3.jpg"></a></p><p><a href="/images/posts/year_summary_2018/photo-baiyin-884-4.jpg"><img data-src="/images/posts/year_summary_2018/photo-baiyin-884-4.jpg"></a></p><p>下面的照片均是在西北铜加工厂（884）社区拍摄。</p><p>这是 884 附近的一座山，山上有一块形状酷似像狮子的石头，所以小时候我们都管这个山叫做“狮子山”。不过可能由于石头连年风化，已经随时会滚落下来，才有人在山脚下立了块标识危险牌子。</p><p><a href="/images/posts/year_summary_2018/photo-baiyin-884-1.jpg"><img data-src="/images/posts/year_summary_2018/photo-baiyin-884-1.jpg"></a></p><p>这是一条通往旁边村子的路，货车多半可能是准备进入大山深处，去拉从山中开采的石灰石。水泥路已经被一辆辆超载的大货车压得几乎没有了。</p><p><a href="/images/posts/year_summary_2018/photo-baiyin-884-2.jpg"><img data-src="/images/posts/year_summary_2018/photo-baiyin-884-2.jpg"></a></p><p>这是西北铜加工厂的正门（有两个，这是其一），在当年国企兴旺之时，上下班的时候人们进进出出摩肩接踵，但是现在物是人非，已经看不到什么人进出厂区的大门了。</p><p><a href="/images/posts/year_summary_2018/photo-baiyin-884-5.jpg"><img data-src="/images/posts/year_summary_2018/photo-baiyin-884-5.jpg"></a></p><p>这是通向厂门的桥，当年为了让职工可以在发洪水的时候安全上下班，就修了两座连通厂区和家属区的桥。桥下还有一个足球场，在发洪水的时候用作泄洪（我们称为“沙沟”），这两座桥似乎一个名为“兴旺桥”，一个名为“振兴桥”，但是年久失修，现在已经是两座危桥了。</p><p><a href="/images/posts/year_summary_2018/photo-baiyin-884-10.jpg"><img data-src="/images/posts/year_summary_2018/photo-baiyin-884-10.jpg"></a></p><p>这是奶奶之前工作过的食堂，由于年久失修，们都已经被水泥封了起来。透过门缝，还能看见火红的标语，一刹那间仿佛又回到了当年。</p><p><a href="/images/posts/year_summary_2018/photo-baiyin-884-6.jpg"><img data-src="/images/posts/year_summary_2018/photo-baiyin-884-6.jpg"></a></p><p>这是西铜的职工浴池，我们都叫大澡堂。前几年浴池终于也关闭了，我只能透过蒙着厚厚灰尘的玻璃撇入浴室的一角，找到当年的回忆。</p><p><a href="/images/posts/year_summary_2018/photo-baiyin-884-7.jpg"><img data-src="/images/posts/year_summary_2018/photo-baiyin-884-7.jpg"></a></p><p>这是当年“达利居”饭庄（之后改名为西铜宾馆）的舞厅。据说西铜鼎盛的时期，会有许多年轻的男男女女穿梭在其中。不过我记事的时候已经没有什么人了。</p><p><a href="/images/posts/year_summary_2018/photo-baiyin-884-8.jpg"><img data-src="/images/posts/year_summary_2018/photo-baiyin-884-8.jpg"></a></p><p>这是一座无名小山上凉亭的一角。当时厂里希望把这座山修成一座公园，于是修整了山道，修建了几座凉亭。不过还没修好，就已经开始亏损，这座公园也就只剩下这两个凉亭了。</p><p><a href="/images/posts/year_summary_2018/photo-baiyin-884-9.jpg"><img data-src="/images/posts/year_summary_2018/photo-baiyin-884-9.jpg"></a></p><p>以上都是我在西铜或者说是白银记忆的一个小角落，还有大量我的、同学的、长辈们的记忆有待挖掘。现在的西铜，已经破败不堪。一眼望去，只有一座座废弃的建筑和一望无际的荒山。一路走去，已经很少能碰见朝气蓬勃的年轻人，只有沟壑纵横的长辈们。这座城因他们而生，也注定会随着他们离去而消失殆尽。所以，我能做的，就是尽量用图片和文字来保留着座终将消失的城，留住他们珍贵的记忆。</p><h1 id="出游"><a href="#出游" class="headerlink" title="出游"></a>出游</h1><p>相比前几年，今年出行的地方没有那么多，但是每个地方都很值得好好留念。正所谓——世界很大，不能只看去了哪里，还要看是和谁一起去的。</p><h2 id="苏州"><a href="#苏州" class="headerlink" title="苏州"></a>苏州</h2><p>2018 年出行的第一站是苏州，这也是我走过得祖国河山中最喜欢的地方之一。苏州不仅有数不尽的美丽景致，更有独特且很有内涵的地方文化，更有令人适宜的生活环境。更重要的呐，这还是和卤蛋同学第一次一起出远门旅行。刚好还欠卤蛋同学一个游记，就先在这里简要地写一下好了。</p><p>苏州城区不大，只靠地铁和公交在一个小时之内都可以到达。但是在城内逛游的时候真的可以感受到就像它的园林一般的一步一景。走着走着，就会出现一座很漂亮的古桥，又向前走两步，就到了一个小有名气的私家园林，再向前一看，发现这不是一家百年老字号嘛（快快快去吃好吃的别看了）。</p><p>另外，苏州话也非常有特色。虽然我听不懂，但是可以感到说话的人都还挺温柔的（就算骂人都骂的很柔），在苏州评弹里就更能体现了，每一个曲调都很柔美，让它所表达的故事格外的柔美。当地人也都十分热心，问路时候可以感受到他们十分有耐心，说话比较慢，令人舒适感倍增。当然，这也从侧面体现了他们生活比较安逸，节奏比较慢。</p><p>下面，我贴几张比较有意思的照片好了。</p><p>这是刚到苏州时候，沿着一条街向虎丘走，卤蛋同学在街边特别激动，左拍拍右拍拍。我刚好留意到他们街头布置得很细心，很能为街道环境和有宠物的人着想，在墙边设立了宠物便纸箱。</p><p><a href="/images/posts/year_summary_2018/photo-suzhou-1.jpg"><img data-src="/images/posts/year_summary_2018/photo-suzhou-1.jpg"></a></p><p>街角一转，居然到了到了河边。河边灰白色的天空衬着灰白色的墙，倒映在水里，十分宁静。这时，船夫划着一艘游船从远处徐徐开来，扰乱了湖水，也令人在心中荡起了浅浅的涟漪。</p><p><a href="/images/posts/year_summary_2018/photo-suzhou-2.jpg"><img data-src="/images/posts/year_summary_2018/photo-suzhou-2.jpg"></a></p><p>虎丘山中的一个沟壑。虽然小，但也有了一种悬崖峭壁的感觉，沟底的水中映出来天上的雨滴，植物颜色十分撞眼，犹如通往世外桃源的一条幽径。</p><p><a href="/images/posts/year_summary_2018/photo-suzhou-3.jpg"><img data-src="/images/posts/year_summary_2018/photo-suzhou-3.jpg"></a></p><p>市内的一座不知名公园。远望时感觉画面十分饱满，而近观又感到场景十分开阔，眼睛都舍不得多眨一下，生怕错过哪一处的美景。</p><p><a href="/images/posts/year_summary_2018/photo-suzhou-4.jpg"><img data-src="/images/posts/year_summary_2018/photo-suzhou-4.jpg"></a></p><p>苏州评弹剧场内部。老师底蕴深厚，唱腔优美。很多字发的都是古音，所以需要有一块屏幕向观众展示唱词。每唱一曲都会一下子把我带入古代天堂般繁华的苏州，置身闹市之中，但又让我进入心流。</p><p><a href="/images/posts/year_summary_2018/photo-suzhou-5.jpg"><img data-src="/images/posts/year_summary_2018/photo-suzhou-5.jpg"></a></p><p>黄天源的苏州小吃。如果苏州糕点说自己第二好吃，怕是没有什么地方敢说自己是第一了。不过最让我惊喜的是苏面，这是我除了牛肉面以外第二个感到能百吃不厌的面了。</p><p><a href="/images/posts/year_summary_2018/photo-suzhou-6.jpg"><img data-src="/images/posts/year_summary_2018/photo-suzhou-6.jpg"></a></p><p>除了这些，在苏州还有许多有趣的见闻，而且都还有许多没有去到的地方。以后可以有缘再见咯。</p><h2 id="天津"><a href="#天津" class="headerlink" title="天津"></a>天津</h2><p>在暑假的时候去了一趟天津。我在这次旅行中得到了一个惊人结论——天津和北京一样热。所以以后夏天还是老老实实待在实验室吹空调好了。</p><p>即使这么热，天津之眼还是要排很久的队，所以就随手拍了张照。</p><p><a href="/images/posts/year_summary_2018/photo-tianjin-1.jpg"><img data-src="/images/posts/year_summary_2018/photo-tianjin-1.jpg"></a></p><p>天津之行的时候还是我和卤蛋同学在一起一周年的纪念日，于是——再回来以后我受宠若惊呆若木鸡地收到了卤蛋同学送的花（hmmm 这应该也是人生中的第一束花），拿到花以后我甚至不知道该把它放在哪里，是不是应该把它插到水桶里养起来。</p><p><a href="/images/posts/year_summary_2018/photo-tianjin-2.jpg"><img data-src="/images/posts/year_summary_2018/photo-tianjin-2.jpg"></a></p><h2 id="灵山"><a href="#灵山" class="headerlink" title="灵山"></a>灵山</h2><p>高中地理曾经学过——海拔每升高 100 米，气温下降 0.6 摄氏度。这大概是我在灵山之行中最直观的感受了。灵山是北京第一高峰，在门头沟区，几乎已经到了北京同河北的交界处，需要驱车三个小时才能赶到。</p><p>灵山是同潘老师、林博以及卤蛋同学我们一行四人去的。去爬山的时候天还是挺热的，所以我带了一件坛服去御寒。刚开始爬的时候我还很跳腾，但是到了一半左右，山势变陡，狂风大作，气温骤降。已经冷到了骨子里，无奈只好作罢。</p><p>灵山上的风景与山下迥异，像极了西北高原，居然出现了驴子和牦牛。下面是在灵山拍摄的一些照片。</p><p><a href="/images/posts/year_summary_2018/photo-lingshan-1.jpg"><img data-src="/images/posts/year_summary_2018/photo-lingshan-1.jpg"></a></p><p><a href="/images/posts/year_summary_2018/photo-lingshan-2.jpg"><img data-src="/images/posts/year_summary_2018/photo-lingshan-2.jpg"></a></p><p><a href="/images/posts/year_summary_2018/photo-lingshan-3.jpg"><img data-src="/images/posts/year_summary_2018/photo-lingshan-3.jpg"></a></p><h1 id="活动"><a href="#活动" class="headerlink" title="活动"></a>活动</h1><p>今年我也刻意减少了很多不必要的活动。在这说说几个比较有意思的吧。</p><h2 id="Hack-for-Good"><a href="#Hack-for-Good" class="headerlink" title="Hack for Good"></a>Hack for Good</h2><p>我最开心的不是又参与了一次 Hachathon，而是 Hackathon 成为了俱乐部每年的例行活动（而且这一场还是卤蛋同学参与办的）。</p><p>这次 Hachaton 弹幕派作为合作方参与到了其中，并且我也带团队来和大家一起 Hack 了两天，成果显著，做好了小程序和控制面板上线前的最后准备。</p><p><a href="/images/posts/year_summary_2018/photo-hackforgood-1.jpg"><img data-src="/images/posts/year_summary_2018/photo-hackforgood-1.jpg"></a></p><p><a href="/images/posts/year_summary_2018/photo-hackforgood-2.jpg"><img data-src="/images/posts/year_summary_2018/photo-hackforgood-2.jpg"></a></p><p><a href="/images/posts/year_summary_2018/photo-hackforgood-3.jpg"><img data-src="/images/posts/year_summary_2018/photo-hackforgood-3.jpg"></a></p><h2 id="SDN-大赛"><a href="#SDN-大赛" class="headerlink" title="SDN 大赛"></a>SDN 大赛</h2><p>还有一件值得一提的事情是搞了两年的 SDN 大赛终于以二等奖为结果圆满收官。比赛中强哥、天骄、高钱、格格这些队友都十分给力，另外加上小雨姐和潘老师的助攻，让我们成功杀入了决赛圈。</p><p><a href="/images/posts/year_summary_2018/photo-sdn-competition.jpg"><img data-src="/images/posts/year_summary_2018/photo-sdn-competition.jpg"></a></p><p>现在看来，我做了一年的 P4 实验系统也随着这个比赛到了的尾声。一年以来，我总是在不断地在这个系统的 Bug 和 Debug 中度过，每天总是担心训练效果不是很理想（事实证明效果的确也不理想）。前些日子，基于这个系统的 INT 遍历算法中了一篇 Infocom，也算是这套系统的最大成就吧。</p><h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><p>今年最令我担心的就是我的技术了。因为离工作的日子越发的近，我却还是没有一门能拿得出手的技术。这些年来，我做了挺多多，了解了挺多，都是项目要用到什么就去学习什么，一直没有给自己找到一个能够系统深入的方向，说起来也很是惭愧。</p><p>不过下半年也算是有一个好的开始吧。我开始去刷 Leetcode（刷过的题目都可以在博客中的<a href="/leetcode">leetcode 板块</a>看到），去看一些框架的源码，开始做 Go 语言的项目，去了解容器和一些 Linux 协议栈相关的知识。现在看来，能做的就只能是再接再厉，不要再掉链子了。</p><h1 id="弹幕派"><a href="#弹幕派" class="headerlink" title="弹幕派"></a>弹幕派</h1><p>在这里我也给弹幕派做一个年终总结吧。</p><p>去年一年，弹幕派的增长效果还不错。在推广营销投入几乎为 0 ，且前有夹击后有追兵的情况下，靠着之前的老本，在用户量和营收上都得到了明显的增长。</p><p>在今年一年，一共有数万个用户注册了弹幕派账号，成功举办了几千场大大小小的活动。一共有数十万人参与到了活动现场的弹幕互动中，产生了数百万条弹幕，并产生了数万个付费订单。另外，弹幕派网站创造了数百万的 PV 和几十万的 UV。这在互联网公司看来可能都不算什么，但是对于我们团队来说，是一个不小的进步。</p><p>我们也投入了大量的精力在研发上面。我们在去年年初就将系统迁移到了 Swarm 集群中，并配置了半自动的编码、发布、测试、预览、上线的环境，经过一年的实践，系统运行良好。而在前端层面，我们将原有的多种技术栈进行了整合，都迁移到了以 Vue 为基础的技术栈中，这样团队成员在不同项目之间切换就变得游刃有余。而后端我们继续沿用了 Laravel+Workerman 的架构，并感到目前还远远没有到达天花板。</p><p>今年的状况就是这样，期待明年可以有更强劲的增长吧。</p><h1 id="一些小事儿"><a href="#一些小事儿" class="headerlink" title="一些小事儿"></a>一些小事儿</h1><p>今年有两次去同学家里做客的经历。一次是同卤蛋同学一起去胃寒家，一起做了一大桌菜（感谢心灵手巧的胃寒和蓉蓉）；另一次是自己去牧野家，一起吃了一顿史上最小的小火锅（感谢牧野和小团子的精心准备）。</p><p>吃腻了学校的食堂，有时候觉得能和爱人在自己家里做饭吃（特别是再和朋友一起煮一锅热气腾腾的火锅，一起聊聊天），的确是很开心的。所以我有时候也开始对未来在外面打拼的时光充满期待。谁知道呢，或许也是一座围城吧。</p><p>年中的时候我也拿到了驾照，不过今年唯一一次路驾还是和牧野，从中关村开到了学校。以后有机会还得多开车，向着老司机的行列迈进。</p><p>年末的时候玩了今年的唯一一款游戏《古剑奇谭 3》，虽然游戏只花了 99，但是我体验到了几倍于价格的诚意。游戏画面精美，优化十分到位，我在大一时候买的 Y400 在现在还能基本流畅地进行游戏，即时战斗也颇为精彩。而在游戏中，文明的光芒、历史的厚重与人类的传承在我的眼前徐徐展开，而主角之间那种的真情也让我倍感舒适。比起之前玩的仙侠类的 RPG，古剑三的进步不止一点点。最近有机会我想专门写一篇相关的文章。</p><h1 id="沉重的话题"><a href="#沉重的话题" class="headerlink" title="沉重的话题"></a>沉重的话题</h1><p>2018 年这一年，有很多人离开了我。包括我的亲人，以及许多敬重的人。</p><p>奶奶是 2 月份走的，现在每每想起心中依旧难以平静。而在这之后，这一年难过的事情就没有中断。</p><p>回忆了一下，逝去的科学巨匠有霍金和高锟。霍金的黑洞理论其价值非我所能评论，但是他的《时间简史》以及《果壳中的宇宙》陪伴了我整个少年时期。而高锟所发明的光纤正构成了我们现在有线通信的根基。他们的逝世是全人类的一大损失，随着他们的离开，科学世界的光芒也变得暗淡了许多。搜索后我才知道，仅 2018 年，就有 31 名两院院士离开了我们。这怕是绝无仅有的。他们共和国的栋梁，他们的贡献深刻地影响着我们的生活，我深切缅怀他们。</p><p>除他们外，还有许多社会知名人士也相继逝世，他们许多人对我们的社会有着深刻的影响。联合国秘书长安南是一个小时候经常听到的名字，他所在的时候，也是联合国知名度最高的时候，他纵横捭阖，致力于解决国际争端，给全人类一个美好的世界。著名主持人李咏的去世也勾起了我对童年的回忆，在印象中，他是一个每天都很欢乐，手持锤子打电话砸金蛋的主持人，但从没想过他会这么快就离开这个世界。而他和哈林的爱情故事，更令我十分动容。除此之外，对文化影响很深的还有金庸、李敖和曾仕强。金庸无需我多言，小时候看的很多武侠小说和电视剧都出自他手，他告诉了我什么是江湖，也给我带来了无数乐趣。李敖和曾仕强是台湾的两位思想家。其中，曾仕强《易经》可能是百家讲坛最受欢迎的节目之一了，他讲的内容大多记不得了，但是他那种睿智而又儒雅的风格令我印象深刻。</p><p>最后，还有田家炳先生。田家炳先生在国内可能没有邵逸夫那么有名，但是他也捐助了无数学校，让这些学校可以改建校舍，购置教具，相互交流，提升教学质量。我所读的高中就是一所田家炳中学在上高中的时候，我们体验到了新的教学楼，用上了很高级的电子白板。而在我们毕业后，学校也将土操场进行了翻新，还新建了装备齐全的科学楼。这其中有很大程度上都是由于他老人家。作为一名田家炳中学的学生，听到他逝去的消息，我的心情相当沉痛。</p><p>而我们国家也正在经历“百年未有之大变局”。这一年随着贸易战开打，经济局势开始变得紧张起来。随着数字货币、互联网借贷和共享单车的迅速衰落，互联网产业也迎来了变数很大的一个时期。独角兽们即使股票纷纷破发，也要流血上市，而下半年来更是处处风传裁员浪潮。这一年注定是一场场艰难的战役。</p><h1 id="The-End"><a href="#The-End" class="headerlink" title="The End"></a>The End</h1><p>不论如何，时间是不会停下来等人的。现在，2018 年已经过去，2019 年已经到来。该面对的还是要面对，该承受的也要去承受。</p><p>上面所回忆的事情，不论好事坏事，不论是否开心，也只是生活中事情的一少部分，生活中更多的事情，是稀松平常，甚至结束以后就会忘记的。但是，这些事情其实才是生活的主旋律。倘若可以在这些事情之中发现美，生活也就会有更多的乐趣了。</p><p>2019 注定依旧是很有悬念的一年，不能守成，还需不断奋斗。加油吧！</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=865460483&auto=0&height=66"></iframe>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Intro&quot;&gt;&lt;a href=&quot;#Intro&quot; class=&quot;headerlink&quot; title=&quot;Intro&quot;&gt;&lt;/a&gt;Intro&lt;/h1&gt;&lt;p&gt;倏忽之间，又过去了一年。是时候向 2018 说一声再见了。&lt;/p&gt;
&lt;p&gt;今年，我只在写 &lt;a href=&quot;/feelings_around_new_year&quot;&gt;年关随笔&lt;/a&gt; 时立了一个 Flag，要练习深度写作，至少每个月输出一篇文章。可惜因为暑假时候偷懒，这个 Flag 也并没有达成。不过，我还是要在 2019 重新立起这样一个 Flag —— 2019 年每个月至少输出一篇文章，可以是技术，可以是随笔，也可以是观点。希望明年这个时候再回来看，不要像今年一样打脸。&lt;/p&gt;
&lt;p&gt;再说回 2018。这一年相比前些年，在我的努力下，节奏逐渐慢了下来，让我有了许多时间静下心来思考、做事，也有时间和爱人相处、与朋友侃大山（至少在十一月之前是这样的）。同时，这一年又并不像以往那么顺遂，让我明白了人力有限，世间有太多力所不能及之事。&lt;/p&gt;
&lt;h1 id=&quot;时光·记忆&quot;&gt;&lt;a href=&quot;#时光·记忆&quot; class=&quot;headerlink&quot; title=&quot;时光·记忆&quot;&gt;&lt;/a&gt;时光·记忆&lt;/h1&gt;&lt;p&gt;在大自然面前，没有什么是能够永恒的。人不能够，事不能够，城也不能够，甚至文明也不能够。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://blog.zhengi.me/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="年终总结" scheme="https://blog.zhengi.me/categories/%E9%9A%8F%E7%AC%94/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="年终总结" scheme="https://blog.zhengi.me/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>解决IOS中微信浏览器软键盘弹出导致的若干Bug</title>
    <link href="https://blog.zhengi.me/the_solution_of_bugs_on_wechat_in_ios/"/>
    <id>https://blog.zhengi.me/the_solution_of_bugs_on_wechat_in_ios/</id>
    <published>2018-12-05T03:24:24.000Z</published>
    <updated>2024-03-23T06:03:16.947Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题-1-键盘弹起后会遮挡键盘上方的内容"><a href="#问题-1-键盘弹起后会遮挡键盘上方的内容" class="headerlink" title="问题 1 键盘弹起后会遮挡键盘上方的内容"></a>问题 1 键盘弹起后会遮挡键盘上方的内容</h1><p>在微信浏览器中，如果需要模拟一个类似微信聊天的窗口，那么一般情况下需要将输入框使用 fixed 定位放置在页面最下方。就像这样：</p><p><a href="/images/posts/the_solution_of_bugs_on_wechat_in_ios/wechat-ios-bug1.png"><img data-src="/images/posts/the_solution_of_bugs_on_wechat_in_ios/wechat-ios-bug1.png"></a></p><p>但是，在 IOS 中的虚拟键盘和 Android 里是不同的。在 IOS 中，虚拟键盘弹出以后，键盘上面的输入提示会比键盘弹出慢半拍，所以就会导致输入法的提示框将正常页面挡住的情况。</p><span id="more"></span><p>这时候，就需要在键盘弹出后，等待一段时间（几百毫秒），然后再将页面的滚动条进行调整，就可以让页面弹到键盘之上。</p><p>假设页面布局如下（使用了 Vue 框架），其中 Dialogues 组件是可以滚动的聊天内容，PageFooter 是使用 fixed 定位在页面底部的输入框：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;mainPanel&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;dialogueContent&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Dialogues</span>&gt;</span><span class="tag">&lt;/<span class="name">Dialogues</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">PageFooter</span>&gt;</span><span class="tag">&lt;/<span class="name">PageFooter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，就可以在监听到软键盘打开事件（比如 dialogueContent 中 input 元素的 onclick 或者 onchange 事件）后，执行下面的语句，让 dialogContent 的滚动条向下滚动,这样里面的内容就不会被覆盖了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dialogueContent = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#dialogueContent&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    dialogueContent.<span class="property">scrollTop</span> = dialogueContent.<span class="property">scrollHeight</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        dialogueContent.<span class="property">scrollTop</span> = dialogueContent.<span class="property">scrollHeight</span></span><br><span class="line">    &#125;, <span class="number">250</span>)</span><br><span class="line">&#125;, <span class="number">250</span>)</span><br></pre></td></tr></table></figure><p>至于为什么要触发两次呢，是因为 IOS 手机种类比较多，从五六年前 iPhone5s 到最新的 iPhoneXR 都有人在用，每种手机的响应速度也各不相同，有些手机可能在第一个 250ms 内还没有完成键盘弹出的工作，所以可以再加一个定时器来兼容旧的手机。</p><p>但问题也依旧存在，就是 fixed 定位的输入框在软键盘弹出以后就不会像 Android 一样固定在页面底部，而是可以上下滑动，类似于 absolute 定位。这时，可以将 body 设置为 absolute 定位，然后再将 MainPage 使用 absolute 定位于 body 底部。</p><h1 id="问题-2-在虚拟键盘收起以后-body-定位的问题"><a href="#问题-2-在虚拟键盘收起以后-body-定位的问题" class="headerlink" title="问题 2 在虚拟键盘收起以后 body 定位的问题"></a>问题 2 在虚拟键盘收起以后 body 定位的问题</h1><p>紧接着，第二个问题就出现了。在点击虚拟键盘右上角的“完成按钮以后”，页面下方并没有回弹，而是定在了原来软键盘上方的位置，必须在页面上滑动两下才可以触发回弹。（特别是在大屏的 IOS 手机上）</p><p>大概是这样：</p><p><a href="/images/posts/the_solution_of_bugs_on_wechat_in_ios/wechat-ios-bug2.png"><img data-src="/images/posts/the_solution_of_bugs_on_wechat_in_ios/wechat-ios-bug2.png"></a></p><p>而在将 body 设置为 absolute 以后，情况更加离奇。页面 UI 是回弹了，但是触控事件响应的位置是没有回弹的，依旧是软键盘打开区域的上方。解决方法同样是必须在页面上方华东两下才能回弹。</p><p>大概是这样：</p><p><a href="/images/posts/the_solution_of_bugs_on_wechat_in_ios/wechat-ios-bug3.png"><img data-src="/images/posts/the_solution_of_bugs_on_wechat_in_ios/wechat-ios-bug3.png"></a></p><p>最开始的想法是去监听 resize 事件，如果软键盘收回，就强行调整 body 的高度，但是发现软键盘的弹出和收回并不会触发该事件，只得作罢。</p><p>最终，找到了一篇解决 <a href="https://www.codercto.com/a/43883.htmlshtml">类似问题的文章</a>，才找到了解决方案。</p><p>大致思路就是在键盘收回以后，主动触发浏览器对页面的重绘操作。如何进行呢？只需要在监听到 onblur 事件以后，让页面滚动到原来的位置即可。</p><p>比如，组件模板中的 HTML 为</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;发送内容&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;content&quot;</span> @<span class="attr">blur</span>=<span class="string">&quot;resizeWindow&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后可以在 JS 的 methods 中添加一个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">resizeWindow</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span> = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，输入框在失去焦点以后会触发页面的重绘，刚刚的问题就随之而解了。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;问题-1-键盘弹起后会遮挡键盘上方的内容&quot;&gt;&lt;a href=&quot;#问题-1-键盘弹起后会遮挡键盘上方的内容&quot; class=&quot;headerlink&quot; title=&quot;问题 1 键盘弹起后会遮挡键盘上方的内容&quot;&gt;&lt;/a&gt;问题 1 键盘弹起后会遮挡键盘上方的内容&lt;/h1&gt;&lt;p&gt;在微信浏览器中，如果需要模拟一个类似微信聊天的窗口，那么一般情况下需要将输入框使用 fixed 定位放置在页面最下方。就像这样：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/images/posts/the_solution_of_bugs_on_wechat_in_ios/wechat-ios-bug1.png&quot;&gt;&lt;img src=&quot;/images/posts/the_solution_of_bugs_on_wechat_in_ios/wechat-ios-bug1.png&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但是，在 IOS 中的虚拟键盘和 Android 里是不同的。在 IOS 中，虚拟键盘弹出以后，键盘上面的输入提示会比键盘弹出慢半拍，所以就会导致输入法的提示框将正常页面挡住的情况。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.zhengi.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="微信" scheme="https://blog.zhengi.me/tags/%E5%BE%AE%E4%BF%A1/"/>
    
    <category term="前端" scheme="https://blog.zhengi.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>在容器中搭建简单的Vxlan隧道</title>
    <link href="https://blog.zhengi.me/vxlan_tunnel_with_container/"/>
    <id>https://blog.zhengi.me/vxlan_tunnel_with_container/</id>
    <published>2018-11-22T12:30:00.000Z</published>
    <updated>2024-03-23T06:03:16.947Z</updated>
    
    <content type="html"><![CDATA[<p>现在，Docker 已经成为了一个非常主流的虚拟化技术，它集合了 Linux 中的许多虚拟化技术，如 Namespace、cgroup 和 AUFS 等等，所以我们可以使用 Docker 搭建一个开箱即用的虚拟化容器。但是，Docker 网路在很多时候依旧不能满足应用场景中的需求，这就需要我们对 Docker 中的网络进行自定义了。</p><p>这篇博客就是关于位于不同虚拟机中的两个容器实现 vxlan 通信的实验。</p><h1 id="拓扑和环境"><a href="#拓扑和环境" class="headerlink" title="拓扑和环境"></a>拓扑和环境</h1><p>首先讲一下实验拓扑吧，它大概长下面这个样子。</p><p><a href="/images/posts/vxlan_tunnel_with_container/docker-vxlan-topo.png"><img data-src="/images/posts/vxlan_tunnel_with_container/docker-vxlan-topo.png"></a></p><p>一共两台虚拟机，在两台虚拟机之间使用交换机连接。在虚拟机内部各有一个容器，容器和主机通过 bridge 连接，而这两个虚拟机之间需要通过 vxlan 进行连接。</p><span id="more"></span><p>而我所使用的虚拟机是位于 vSpere 中的两台主机，他们采用 vSphere 中的虚拟机端口组相连，并且该端口组开启了<em>混杂模式</em>。两台虚拟机均为 Ubutnu18.04 系统，Docker 也为最新版本。</p><p>我还基于 Docker Hub 中的 Ubuntu 镜像封装了一个带有 ifconfig、ping、ip 和 python 命令的镜像，可以通过<code>docker pull bzzdzc/myubuntu</code>命令获取。</p><p>当然你可以通过在容器中的命令行内运行如下 apt-get 命令来安装这些软件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">// ifconfig</span><br><span class="line">apt install net-tools</span><br><span class="line">//ping</span><br><span class="line">apt install iputils-ping</span><br><span class="line">//ip</span><br><span class="line">apt install iproute2</span><br></pre></td></tr></table></figure><h1 id="开始搭建网络"><a href="#开始搭建网络" class="headerlink" title="开始搭建网络"></a>开始搭建网络</h1><h2 id="配置-VM1-中的网络"><a href="#配置-VM1-中的网络" class="headerlink" title="配置 VM1 中的网络"></a>配置 VM1 中的网络</h2><p>现在开始在 VM1 中对网络进行配置。</p><h3 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw <span class="built_in">disable</span></span><br></pre></td></tr></table></figure><h3 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h3><p>需要注意的是，在运行 Docker 时，选择不连接网络，之后我会将它连接到自己建立的网桥上面去。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --network none --name myubuntu1 myubuntu</span><br></pre></td></tr></table></figure><h3 id="记录容器中主进程的名称空间"><a href="#记录容器中主进程的名称空间" class="headerlink" title="记录容器中主进程的名称空间"></a>记录容器中主进程的名称空间</h3><p>首先，查看容器主进程的 PID，然后将其保存到$pid 变量中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> myubuntu1</span><br><span class="line">pid=$(docker inspect --format <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> myubuntu1)</span><br></pre></td></tr></table></figure><p>然后，将该 pid 链接至/var/run/netns 中，以便 ip netns 命令可以访问到它。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /var/run/netns</span><br><span class="line">sudo <span class="built_in">ln</span> -s /proc/<span class="variable">$pid</span>/ns/net /var/run/netns/<span class="variable">$pid</span></span><br></pre></td></tr></table></figure><h3 id="创建-veth-peer"><a href="#创建-veth-peer" class="headerlink" title="创建 veth peer"></a>创建 veth peer</h3><p>我们通过创建一对 veth peer A 和 B 来维持虚拟机主机通容器之间的通信。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip <span class="built_in">link</span> add A <span class="built_in">type</span> veth peer name B</span><br></pre></td></tr></table></figure><h3 id="创建新的网桥"><a href="#创建新的网桥" class="headerlink" title="创建新的网桥"></a>创建新的网桥</h3><p>这一步创建了一个名为 br-vx 的网桥，并将其状态设置为 up。然后，为网桥分配 ip 地址 192.168.0.1/24。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo brctl addbr br-vx</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> br-vx up</span><br><span class="line">sudo ip addr add 192.168.0.1/24 dev br-vx</span><br></pre></td></tr></table></figure><h3 id="将物理端口和-veth-端口-A-分别链接至网桥"><a href="#将物理端口和-veth-端口-A-分别链接至网桥" class="headerlink" title="将物理端口和 veth 端口 A 分别链接至网桥"></a>将物理端口和 veth 端口 A 分别链接至网桥</h3><p>虚拟机的物理端口一般为 ens32，我们将该端口连接至刚创建的网桥中。</p><p>然后我们将刚刚创建的 veth 的 A 端口绑定到网桥中，并设置其为 up。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo brctl addif br-vx ens32</span><br><span class="line">sudo brctl addif br-vx A</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> A up</span><br></pre></td></tr></table></figure><h3 id="将-veth-端口-B-绑定到容器的名称空间中"><a href="#将-veth-端口-B-绑定到容器的名称空间中" class="headerlink" title="将 veth 端口 B 绑定到容器的名称空间中"></a>将 veth 端口 B 绑定到容器的名称空间中</h3><p>这一步将 veth 的 B 端口放置于容器中，并将其命名为容器中的 eth0.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> B netns <span class="variable">$pid</span></span><br><span class="line">sudo ip netns <span class="built_in">exec</span> <span class="variable">$pid</span> ip <span class="built_in">link</span> <span class="built_in">set</span> dev B name eth0</span><br><span class="line">sudo ip netns <span class="built_in">exec</span> <span class="variable">$pid</span> ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 up</span><br></pre></td></tr></table></figure><h3 id="为容器中的-eth0-端分配-IP-地址"><a href="#为容器中的-eth0-端分配-IP-地址" class="headerlink" title="为容器中的 eth0 端分配 IP 地址"></a>为容器中的 eth0 端分配 IP 地址</h3><p>为容器中分配 IP 地址 192.168.0.100/24。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip netns <span class="built_in">exec</span> <span class="variable">$pid</span> ip addr add 192.168.0.100/24 dev eth0</span><br></pre></td></tr></table></figure><p>现在，如果配置正确，使用命令<code>docker exec -it myubuntu1 bash</code>进入容器中的命令行后，运行<code>ping 192.168.0.1</code> ，应该已经可以得到主机的回应了。</p><h3 id="配置-VM1-中的-vxlan-连接"><a href="#配置-VM1-中的-vxlan-连接" class="headerlink" title="配置 VM1 中的 vxlan 连接"></a>配置 VM1 中的 vxlan 连接</h3><p>这里需要现在容器中创建一个 vxlan 连接。我们规定它的 id 为 100，而 vxlan 底层网络连接两端的 IP 分别为两个容器的 IP 192.168.0.100（本段）和 192.168.0.101（对端）。</p><p>然后设置 vxlan 隧道的 IP 为 10.0.0.1/24。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo ip netns <span class="built_in">exec</span> <span class="variable">$pid</span> ip <span class="built_in">link</span> add vxlan1 <span class="built_in">type</span> vxlan <span class="built_in">id</span> 100 remote 192.168.0.101 <span class="built_in">local</span> 192.168.0.100 dstport 4789</span><br><span class="line">sudo ip netns <span class="built_in">exec</span> <span class="variable">$pid</span> ip <span class="built_in">link</span> <span class="built_in">set</span> vxlan1 up</span><br><span class="line">sudo ip netns <span class="built_in">exec</span> <span class="variable">$pid</span> ip addr add 10.0.0.1/24 dev vxlan1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="配置-VM2-中的网络"><a href="#配置-VM2-中的网络" class="headerlink" title="配置 VM2 中的网络"></a>配置 VM2 中的网络</h2><p>VM2 中网络的配置方法和 VM1 中类似，只是分配的 IP 地址有些变化。</p><ul><li>给 VM2 中网桥分配的 IP 地址变为 192.168.0.2/24</li><li>给 VM2 中容器里的 eth0 端口分配的 IP 地址变为 192.168.0.101/24</li><li>给 VM2 中 vxlan 连接分配的本端 IP 地址变为 10.0.0.2/24</li></ul><p>另外，在 vxlan 网络配置好之前，就已经可以使用 ping 命令测试底层网络网路的连通性了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//测试和容器的连通性</span><br><span class="line">ping 192.168.0.101</span><br><span class="line">//测试和VM1的连通信</span><br><span class="line">ping 192.168.0.1</span><br><span class="line">//测试和VM1中容器的连通性</span><br><span class="line">ping 192.168.0.100</span><br></pre></td></tr></table></figure><h2 id="测试-vxlan-网络的连通性"><a href="#测试-vxlan-网络的连通性" class="headerlink" title="测试 vxlan 网络的连通性"></a>测试 vxlan 网络的连通性</h2><p>这个其实非常简单，依旧是使用 ping 命令。</p><p>首先，在 VM1 中进入容器内测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it myubuntu1 bash</span><br><span class="line">ping 10.0.0.2</span><br></pre></td></tr></table></figure><p>然后，在 VM2 中进入容器内测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it myubuntu1 bash</span><br><span class="line">ping 10.0.0.1</span><br></pre></td></tr></table></figure><p>如果双方都可以连通，那就说明基于 vxlan 的 隧道已经创建成功。</p><h1 id="其它注意事项"><a href="#其它注意事项" class="headerlink" title="其它注意事项"></a>其它注意事项</h1><h2 id="有关混杂模式"><a href="#有关混杂模式" class="headerlink" title="有关混杂模式"></a>有关混杂模式</h2><p>首先需要注意的是，由于我们在 VM 中创建了容器，而又把 VM 和容器中的端口都绑定到了网桥上，所以，从 VM 中出去的包的 MAC 地址可能 VM 的也可能是容器的。由于安全策略限制，esxi 中的虚拟交换机默认会丢弃非 VM MAC 地址的包，这时就必须要开启混杂模式，让它不对源 MAC 地址进行验证。具体原理可以参考：<a href="http://blog.51cto.com/9843231/2294188?source=drh">http://blog.51cto.com/9843231/2294188?source=drh</a></p><h1 id="一些参考资料"><a href="#一些参考资料" class="headerlink" title="一些参考资料"></a>一些参考资料</h1><ul><li><a href="https://www.cnblogs.com/sammyliu/p/5878973.html">理解 Docker（3）：Docker 使用 Linux namespace 隔离容器的运行环境</a></li><li><a href="https://www.cnblogs.com/wade-luffy/p/6589254.html">Docker 核心实现技术(命名空间&amp;控制组&amp;联合文件系统&amp;Linux 网络虚拟化支持)</a></li><li><a href="https://www.cnblogs.com/weifeng1463/p/6805530.html">使用 CentOS Linux Bridge 搭建 Vxlan 环境</a></li><li><a href="https://blog.csdn.net/sld880311/article/details/77650937">Linux-虚拟网络设备-veth pair</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;现在，Docker 已经成为了一个非常主流的虚拟化技术，它集合了 Linux 中的许多虚拟化技术，如 Namespace、cgroup 和 AUFS 等等，所以我们可以使用 Docker 搭建一个开箱即用的虚拟化容器。但是，Docker 网路在很多时候依旧不能满足应用场景中的需求，这就需要我们对 Docker 中的网络进行自定义了。&lt;/p&gt;
&lt;p&gt;这篇博客就是关于位于不同虚拟机中的两个容器实现 vxlan 通信的实验。&lt;/p&gt;
&lt;h1 id=&quot;拓扑和环境&quot;&gt;&lt;a href=&quot;#拓扑和环境&quot; class=&quot;headerlink&quot; title=&quot;拓扑和环境&quot;&gt;&lt;/a&gt;拓扑和环境&lt;/h1&gt;&lt;p&gt;首先讲一下实验拓扑吧，它大概长下面这个样子。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/images/posts/vxlan_tunnel_with_container/docker-vxlan-topo.png&quot;&gt;&lt;img src=&quot;/images/posts/vxlan_tunnel_with_container/docker-vxlan-topo.png&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一共两台虚拟机，在两台虚拟机之间使用交换机连接。在虚拟机内部各有一个容器，容器和主机通过 bridge 连接，而这两个虚拟机之间需要通过 vxlan 进行连接。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.zhengi.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Docker" scheme="https://blog.zhengi.me/categories/%E6%8A%80%E6%9C%AF/Docker/"/>
    
    
    <category term="Docker" scheme="https://blog.zhengi.me/tags/Docker/"/>
    
    <category term="Network" scheme="https://blog.zhengi.me/tags/Network/"/>
    
    <category term="vxlan" scheme="https://blog.zhengi.me/tags/vxlan/"/>
    
  </entry>
  
  <entry>
    <title>《科技创新与创业》课程总结</title>
    <link href="https://blog.zhengi.me/technology_innovation_enterpreneurship_course_comment/"/>
    <id>https://blog.zhengi.me/technology_innovation_enterpreneurship_course_comment/</id>
    <published>2018-08-06T09:02:42.000Z</published>
    <updated>2024-03-23T06:03:16.947Z</updated>
    
    <content type="html"><![CDATA[<h1 id="intro"><a href="#intro" class="headerlink" title="intro"></a>intro</h1><p>上学期同<a href="http://www.cyprestar.com/">Thesharing</a>以及 Stone 去北大旁听了将近一学期的《科技创新与创业》（课程网站：<a href="http://net.pku.edu.cn/dlib/pkuxstart/">http://net.pku.edu.cn/dlib/pkuxstart/</a>）。 这个课程由百度七剑客之一的雷鸣主持，邀请了很多行业内有名的企业家来讲课，几乎都是北大校友（感慨一下北大校友文化真的很棒）。 我想在这篇文章中总结一下他们所讲的一些能引起我思考的观点和内容，以及经过我提炼加工所得到的结论。</p><h1 id="三角关系"><a href="#三角关系" class="headerlink" title="三角关系"></a>三角关系</h1><p>这里的三角关系并不是指恋爱中的那种复杂关系，而是指一个行业中相互制约的几个要素之间的复杂关系。其中一种要素发生大的变化（一般是非连续性的），这个产业整体以及几个要素之间的相互关系也会随之发生变化，这往往预示着新机会的到来。</p><p>微博 CEO 来去之间举了一个例子——移动互联网中存在的三角关系：运营商、手机制造商和互联网公司。 这个三角关系中某个要素发生变革就会导致移动互联网行业的巨变，会有一波新的公司起来。比如运营商 4G 网络的普及，使得网速变得越来越快，流量变得越来越便宜，这就催生了短视频行业的兴起，这也催生了一系列的公司和产品，比如快手和抖音。</p><span id="more"></span><p>明略数据的吴明辉提出在大数据这个产业中也存在一个三角关系——人、数据源和场景。 数据源在未来物联网时代会发生很大的变化，数据世界中的主导位置可能会从原来的因特网中的数据变为物联网传感器中的数据，这对于很多公司来说是一个全新的机会。</p><p>我认为，这些三角关系代表了一个场景之下的几个利益方，某一个方面出现技术或者认知方面的突破，都会造成行业的重新洗牌。比如在虚拟现实产业链中，不仅仅有设备制造商和内容生产商，还会有运营商的机会，因为 VR 数据的传输需要大量的带宽。所以，5G 时代到来以后，VR 会不会又重新火起来呢？</p><h1 id="产品方法论"><a href="#产品方法论" class="headerlink" title="产品方法论"></a>产品方法论</h1><p>很多嘉宾都不约而同地说到了俞军老师有关用户收益的产品方法论：</p><blockquote><p>产品的价值（用户的收益）= 新体验 - 旧体验 - 迁移成本。</p></blockquote><p>这条方法论十分重要，是衡量你做出的一个新产品是否可以干掉旧产品的一个关键因素（这条方法论也经常被<a href="https://www.jianshu.com/u/55ec7c6b7e42">SGanker</a>提到）。</p><p>我认为这条方法论的基础是一个共识——真正的需求不是被创造出来的，而是来自人类的本性。你所创造的产品是使用了一个新的形式或者新的技术来包装这个古老的需求。所以，一定要想清楚，你在做这个产品的时候到底替代了谁，新的产品解决了什么旧的问题。</p><p>另外一个问题是如何区分真的需求和伪需求。这里 OFO 的戴威提供了一个方法——将这种需求通过英语 Need/Want 归类，如果是 Need，那么这个需求就是真的需求，如果是 Want，那么这个需求就是伪需求。</p><p>不仅仅要检查这个需求是真需求还是伪需求，更要思考这个需求是不是只有自己需要，还是你的朋友也需要，更或许是人人都需要。</p><p>这里也有一个技巧，就是把自己的产品和别人去讲解，看他们是否感兴趣。不过身边的人可能会担心得罪你，不愿意说你产品的坏话，所以可以要找陌生人后者敢于说真话的人来介绍你的产品，来了解这个需求到底是不是真需求。</p><h1 id="顺势而为"><a href="#顺势而为" class="headerlink" title="顺势而为"></a>顺势而为</h1><p>说到顺势而为，我第一个想到的是雷军和他的顺为资本，以及他“风口上的猪”的理论。我想，他也是因为带着金山硬挺了这么多年才悟出的这个道理吧。我想，现在的小米就是他顺势而为的结果。 关于顺势而为，还有一句话我很喜欢，也想放在这里——“一个人的命运，不仅要看个人的奋斗，还要看历史的进程。”这句话从辩证唯物的立场讨论了为什么要顺势而为。</p><p>下面就来讨论一下如何顺势而为。</p><h2 id="从更高的高度来看问题"><a href="#从更高的高度来看问题" class="headerlink" title="从更高的高度来看问题"></a>从更高的高度来看问题</h2><p>微博 CEO 王高飞从很高的层次来分析了微博发展的时候遇到的许多问题以及解决方法。他和他的团队的思考更多的不是现在用户的需求，而是未来五年左右中国经济社会的发展可能会让某些用户的需求变得旺盛，微博就会在这里提前布局。而对于许多目前无法超越的竞争对手，微博选择了从大局考虑，不去正面竞争而更换别的赛道（关于赛道，下面还会提到）。</p><p>比如微博在 2012 年就判断了中国经济未来五年的趋势：比如移动互联网的增量更多来自于二三线城市。而微博当时发力的主要方向就是去做二三线城市的消费升级，上线了一系列针对这部分用户的产品。</p><p>但是这样的分析可能也会有所遗漏，比如微博没有想到五六线城市的下沉也会是一个机会，而这个机会造就了快手的极速增长。</p><p>从这些嘉宾的口中，我也大致总结了大家都认为未来可能会蓬勃发展的行业：</p><ul><li>首先还是互联网和 AI。互联网会和传统行业更深地结合（也就是互联网+），而 AI 也会改造更多的行业。</li><li>另外一个风口是生物医药（我之前的确从未关注过）。由于生物医疗行业中基因组学和蛋白质学这些基础技术的突破，导致未来这个行业很可能会非常蓬勃地发展。现在，投资机构对于生物医药行业的投资已经是仅次于互联网行业的存在了。</li><li>随着中国人口红利的消失，很多产品野蛮生长的机会已经不是很大了。而大家对于消费升级的追求导致会有更多的创新品牌诞生。</li><li>人口红利消失也会导致 2B 的服务会越来越多。</li></ul><p>所以如果要创业，那么一定要选择具有先发优势的行业，即判断未来几年的主力消费人群和用户增量会在什么地方。</p><p>最后需要提到的是，现在全面创业的热潮已经过去，很多创业公司纷纷死去，只有很少具有竞争优势的公司存活了下来。</p><h2 id="赛道的选择十分重要"><a href="#赛道的选择十分重要" class="headerlink" title="赛道的选择十分重要"></a>赛道的选择十分重要</h2><p>赛道理论是投资界的一个理论。他们将某一个细分的行业或领域称之为一个赛道。而这个赛道上会有许多类似的公司在竞争（很像在一起赛跑）。既然是比赛，那么肯定会有前几名，而投资机构就会投资头部的那些具有竞争优势的企。等这个赛道成熟以后，可怕的幂律就会发生作用，前几家公司会吃掉这个赛道中九成以上的市场，后面的公司几乎没有任何机会。</p><p>所以，选择一个自己可以具有竞争优势的赛道就显得十分重要了。关于不同赛道上的公司的信息，可以在一些咨询公司的网站上面看见（比如艾瑞咨询：<a href="http://www.iresearch.com.cn/">http://www.iresearch.com.cn/</a>）。</p><p>另外，你所选择的赛道要具有空间和时间上很强的成长性。有空间的成长性，行业的天花板高，大家有充足的空间赚到很多，才会有人愿意投入资本和时间将这个市场做大。有时间的成长性，说明你做的方向是正确的，等五年到十年以后，时间还是你的朋友。</p><h2 id="市场、产品和技术之间的关系"><a href="#市场、产品和技术之间的关系" class="headerlink" title="市场、产品和技术之间的关系"></a>市场、产品和技术之间的关系</h2><p>因为身边同学多是技术出身，所以我接触到的很多人可能都认为技术对于一个公司而言最重要的。但事实可能并非如此——许多产品是由市场拉动而非技术推动的，一般情况下开发一个市场所花费的成本要远远大于技术。所以开发产品时应当从市场的痛点来着手，而非技术高低。</p><p>不仅市场比技术更重要，产品也比技术更重要。在设计产品的时候需要有用户视角，使用同理心去思考用户的感受，并培养用户使用产品时的参与感。这里好像又说到了产品方法论，既然说到了，不如再举一个例子：腾讯的 10/100/1000 法则。这个法则要求腾讯的产品经理每个月必须做 10 个用户调查，关注 100 个用户博客，收集并反馈 1000 个用户体验。</p><h2 id="商业模式"><a href="#商业模式" class="headerlink" title="商业模式"></a>商业模式</h2><p>一个好的受资本市场欢迎的商业模式需要四个要素：能赚钱（有人买单）、规模性（可复制）、有壁垒（不会被腾讯抄袭）和可持续（未来成长空间很大）。</p><p>更好的商业模式不仅考虑了自身的发展，还要考虑到产业链中整个链条的利益分配问题。</p><h2 id="非连续性机会"><a href="#非连续性机会" class="headerlink" title="非连续性机会"></a>非连续性机会</h2><p>驱动社会经济发展的核心要素是非连续性机会，只有抓住非连续性机会的公司才可能获得爆发式的发展，并且有机会获得垄断地位。</p><h1 id="好公司"><a href="#好公司" class="headerlink" title="好公司"></a>好公司</h1><h2 id="护城河理论"><a href="#护城河理论" class="headerlink" title="护城河理论"></a>护城河理论</h2><p>“护城河”理论是巴菲特提出的。他认为好的公司需要有一条护城河来避免来自外部的竞争。有以下几种创造护城河的方法：</p><ul><li>一种护城河是单一产品规模，公司拥有一个使用规模非常大的产品，以形成规模效应。互联网公司，如腾讯，ebay，沃尔玛等公司都属于这一类。</li><li>另一种是知识产权，比如商标或者一些关键的技术专利。迪士尼、耐克等公司就属于这一类。</li><li>最后一种是客户转用其他产品需要很高的成本。比如 Oracle 和微软。</li></ul><p>几乎所有的好公司都在致力于建立护城河以获取垄断地位，最终占领用户的心智。</p><h2 id="如何与大公司竞争"><a href="#如何与大公司竞争" class="headerlink" title="如何与大公司竞争"></a>如何与大公司竞争</h2><p>我一度认为类似“如果腾讯也开始做你们的产品怎么办？”这种问题是无解的。不过听完课以后，我的思路产生了变化。原因有三：</p><ul><li>首先，你做的业务有可能是巨头们看不上的不怎么赚钱的小业务，除非这个业务以后会成长成为一个巨无霸，那么巨头一般是没有精力或者成本来同你竞争的。但就是这种巨头看不上的业务可能能让你赚的盆满钵满，在未来的某个时间，有娱非连续性机会，这个业务也或许就会成为商业的主战场。</li><li>其次，巨头往往都是上市公司，上市公司往往背负着到很多方面的利益。如果他们需要从赚钱的业务上将资源倾斜到其他需要和创业公司竞争的地方，那么他们的股东和员工都可能会不乐意，甚至股价也会下跌很多。所以，他们很多时候可能会选择投资或者收购而非直接竞争。</li><li>最后，市场中一直都有许多资本，为了不贬值，它们必须被投资到有很大增值潜力的地方，大公司往往增长不会太大，而增长潜力很高的小公司却可以做到。所以资本市场会愿意把钱交给具有很大增值空间的小公司，和大公司去打的。所以，为了可以和大公司竞争，创业公司需要<strong>业务+资本的双轮驱动</strong>。不仅要做好自己的业务，也要积极向外寻求资本，这样才能有一息存活的机会。</li></ul><h2 id="垄断才能创造利润"><a href="#垄断才能创造利润" class="headerlink" title="垄断才能创造利润"></a>垄断才能创造利润</h2><p>能够创造价值的公司并不一定可以创造很好的价格。因为在尚未形成垄断的时候，市场上存在着很多竞争对手，博弈论一定会在这里发挥作用，导致你无法让产品或公司有一个很好的价格。</p><p>这里说的垄断不一定是产品的垄断，还可以是应用场景的垄断。场景垄断垄断的是消费者的心智。比如苹果公司的产品，虽然从来没有在市场上形成单一品类的垄断，但是它们加起来形成了一个生态系统，它们垄断了消费者的心智。苹果公司靠它获得了非常高的利润率。同样垄断也表现在股价上——苹果公司在前几天终于成为了地球上第一家市值突破万亿美元大关的公司。</p><p>这里我还可以用小米公司来举一个例子。小米公司的互联网手机模式在刚出来的时候，受到了众多用户的欢迎，增长非常迅速，表现在资本层面就是估值越来越高。但是随后随着荣耀、OV 等公司加入这个赛道，同小米形成了强力的竞争，小米模式出现了很多问题。小米公司的价值无疑是很高的，但是没有垄断。这种问题表现在股价上就是上市以后几乎两次破发，小米公司并没有得到和价值匹配的好的价格。但是它的生态链以及和用户建立信任关系的商业手段都是在为建立（不同于苹果模式的）新的垄断去做尝试。小米公司的模式究竟能走到何时何地，我们可以拭目以待。</p><h1 id="创始人"><a href="#创始人" class="headerlink" title="创始人"></a>创始人</h1><p>先说一个结论，创始人的高度很大程度上决定了企业的高度。因为企业的文化、商业模式以及关键决策几乎都来自于创始人。不过创始人的高度也不是一成不变的，他们会随着公司的成长不断的学习和成长。</p><h2 id="领导力"><a href="#领导力" class="headerlink" title="领导力"></a>领导力</h2><p>一家公司的创始人往往就是领导者。领导者和管理者有很大的区别。管理者只需要管理员工，按时按量完成任务即可。但是领导人需要通过他的很强的人格魅力来带领大家一起向前。所以领导人不仅需要做事，还需要做人，不仅要做事做人，更需要有很长远的目光。</p><p>做为领导者往往都是很孤独的。麦肯锡健康的樊琴还说，创业不仅孤独，而且几乎没有成就感。因为一切都是从零开始，而且一旦开始就永远没有尽头。</p><p>刚刚说过，创始人的高度很大程度上决定了企业的高度，所以创始人需要很强的学习能力，需要在企业成长的同时也不断学习，要和企业一同成长，甚至要比企业的成长还要迅速。但是，创始人不仅仅需要学习，还需要将他的决策力、执行力、组织力和感召力都输出给其他人，营造气氛，让大家一起干起来，也就是“使众人行”。</p><h2 id="创始人的选择"><a href="#创始人的选择" class="headerlink" title="创始人的选择"></a>创始人的选择</h2><p>OFO 的戴威给出了他选择创始人的思路。首先，公司只能有一个创始人。其次，创始人和联合创始人之间必须要比较知根知底（比如哥们），同时也最好可以兼具能力上的互补。</p><p>另外，价值观的统一也非常重要，创始人之间需要有强烈的相互认可，不然现在的兄弟可能会变成之后的友商。</p><p>最不易稳固的结构是只根据需要能力来选择一些不太熟悉的人，雷鸣认为这样的创始团队算是“草台班子”，而草台班子是迟早要散的。</p><h2 id="投资人的选择"><a href="#投资人的选择" class="headerlink" title="投资人的选择"></a>投资人的选择</h2><p>将好几位老师的话总结一下，就是：投资人不仅要选有钱的，还要选择除了钱以外可以给企业提供更多帮助的人。另外在敲定投资的时候，一些法律问题一定要了解清楚，不然可能会因为协议中的一些条款就让自己倾家荡产。</p><h2 id="商业和社会成熟度"><a href="#商业和社会成熟度" class="headerlink" title="商业和社会成熟度"></a>商业和社会成熟度</h2><p>商业不是过家家，创始人需要很强的商业成熟度和社会成熟度。</p><p>商业成熟度主要反映在对商业本质的认识：比如有客户来源、商业模式、对竞争对手的认识和投资策略等等。创始人没有很好的商业成熟度，公司一定是无法存活的。</p><p>社会成熟度来源于步入社会以后对社会的认识，比如经验、能力、人脉和<strong>价值观</strong>。董小玲认为，这些成熟度在高校中是很难锻炼出来的，而在大学生走上社会的半年左右的时间里，会逐渐积聚。这个时候创业者既对社会有了清醒的认识，还没有忘记自己的理想，是创业的最佳时机。</p><h2 id="家庭关系"><a href="#家庭关系" class="headerlink" title="家庭关系"></a>家庭关系</h2><p>令我诧异的是有很多创业者创业中断的原因不是融资失败、竞争对手或者政策问题等等来自外部的因素，而是因为家庭成员之间意见不一致的问题。这里的家庭成员多是另一半、自己的父母或者是另一半的父母。</p><p>因为创业面临了很大的不确定性，所以如果其他家庭成员（特别是另一半的家长）接受不了这种不稳定性而不同意你去创业，这无异于后院起火，创业很可能就会失败了。</p><p>这里董小玲提到了一个规律，就是如果父母对创业特别懂或者一点都不懂，这都好办，但是如果父母半懂不懂那可能麻烦就会大一些了。</p><p>所以如何平衡创业与家庭之间的关系，是往往被创业者忽略的一个很大的问题。</p><h1 id="一些其他的话题"><a href="#一些其他的话题" class="headerlink" title="一些其他的话题"></a>一些其他的话题</h1><p>以下是嘉宾们对于一些热门话题的比较有趣的观点。</p><h2 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h2><p>邓锋认为，对于区块链应该区分链圈和币圈。区块链解决了信任问题，也解决了价值重新分配的问题，而币圈都是骗子。</p><p>一个技术（比如区块链）的出现并不能颠覆一个行业，只能作为增量而存在。</p><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>吴明辉认为数据是对世界的观察，帮助没有观察的人解决信息不对等的问题。它可以创造信任，降低决策成本，帮助决策者进行快速的决策。但另一个角度来看，数据不一定是真实的，因为它是主观的，它本身也没有任何价值。但是只要它存在，就可以创造信任，而通过信任就会产生很多的价值。</p><p>另外，历史的发展多是不连续的，而数据代表过去，所以过去的数据很难预测长期的未来，但是它可以预测短期的未来。</p><p>商业的本质也是在利用信息不对等来解决问题创造价值，如果利用数据来做生意，使得信息对等了，那么商业就不存在了。所以用数据做生意是商业中的一个悖论。</p><h2 id="商业计划书"><a href="#商业计划书" class="headerlink" title="商业计划书"></a>商业计划书</h2><p>弘道资本的李晓光认为商业计划书的目的是为了获得投资，核心内容是你投资我可以赚大钱。商业计划书的质量决定了 VC 是否会找你进行面对面沟通。</p><p>商业计划书需要准备几种：五分钟版本、演示 PPT、完整计划书、未来财务预测（需要专业的财务模型）。</p><h1 id="推荐书"><a href="#推荐书" class="headerlink" title="推荐书"></a>推荐书</h1><p>课堂上有许多老师给出了推荐阅读的书目，我也在这里略作总结：</p><p>最后，使用戴威的一句话作为文章的结尾吧：</p><blockquote><p>不要迷信于别人的经验和方法论，创业者应该在创业中不断尝试，找到属于自己的方法论。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;intro&quot;&gt;&lt;a href=&quot;#intro&quot; class=&quot;headerlink&quot; title=&quot;intro&quot;&gt;&lt;/a&gt;intro&lt;/h1&gt;&lt;p&gt;上学期同&lt;a href=&quot;http://www.cyprestar.com/&quot;&gt;Thesharing&lt;/a&gt;以及 Stone 去北大旁听了将近一学期的《科技创新与创业》（课程网站：&lt;a href=&quot;http://net.pku.edu.cn/dlib/pkuxstart/&quot;&gt;http://net.pku.edu.cn/dlib/pkuxstart/&lt;/a&gt;）。 这个课程由百度七剑客之一的雷鸣主持，邀请了很多行业内有名的企业家来讲课，几乎都是北大校友（感慨一下北大校友文化真的很棒）。 我想在这篇文章中总结一下他们所讲的一些能引起我思考的观点和内容，以及经过我提炼加工所得到的结论。&lt;/p&gt;
&lt;h1 id=&quot;三角关系&quot;&gt;&lt;a href=&quot;#三角关系&quot; class=&quot;headerlink&quot; title=&quot;三角关系&quot;&gt;&lt;/a&gt;三角关系&lt;/h1&gt;&lt;p&gt;这里的三角关系并不是指恋爱中的那种复杂关系，而是指一个行业中相互制约的几个要素之间的复杂关系。其中一种要素发生大的变化（一般是非连续性的），这个产业整体以及几个要素之间的相互关系也会随之发生变化，这往往预示着新机会的到来。&lt;/p&gt;
&lt;p&gt;微博 CEO 来去之间举了一个例子——移动互联网中存在的三角关系：运营商、手机制造商和互联网公司。 这个三角关系中某个要素发生变革就会导致移动互联网行业的巨变，会有一波新的公司起来。比如运营商 4G 网络的普及，使得网速变得越来越快，流量变得越来越便宜，这就催生了短视频行业的兴起，这也催生了一系列的公司和产品，比如快手和抖音。&lt;/p&gt;</summary>
    
    
    
    <category term="课程" scheme="https://blog.zhengi.me/categories/%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="课程" scheme="https://blog.zhengi.me/tags/%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>《青年马克思》小感</title>
    <link href="https://blog.zhengi.me/about_yound_marx/"/>
    <id>https://blog.zhengi.me/about_yound_marx/</id>
    <published>2018-05-19T14:22:51.000Z</published>
    <updated>2024-03-23T06:03:16.943Z</updated>
    
    <content type="html"><![CDATA[<p>最近得知《青年马克思》上映，觉得有必要一看。于是上网搜了一下院线的排片，不出所料，排片量几乎是最近热映的《复联 3》的五分之一，甚至周末都少有商业影院有排期。于是只能等到周一约上阿文，去附近的影院一睹青年时期马克思的“芳容”。</p><p>刚入座，还在和朋友聊最近的中兴联想发生的一系列事件，电影就毫无防备地开始了。此时一个大概容纳五六十人的小影厅里只稀疏地坐着六七个人，多数还是学生（祖国未来还是很有希望的嘛）。</p><p>电影里的场景暂且不表，先来说说我对电影整体的感受吧。 首先，作为一部传记电影，而且讲述的是一位思想家的成长历程，如果没有一些对马克思生平以及思想的了解，可能就会在电影院呼呼大睡了。这可能会是观影的一个门槛。</p><p>其次，电影内容很丰富。短短不到两个小时，电影讲述了马克思从莱茵报编辑，到论战蒲鲁东，最后是完成《共产党宣言》这三个时期，同时又穿插了马克思与燕妮之间深沉的爱，马克思同恩格斯之间深切的友谊以及恩格斯同玛丽之间跨越阶级的感情。</p><span id="more"></span><p>电影不但对历史事件做到了真实还原，同时还把人物表现得有血有肉，把离我们很远的两位“大胡子”思想家拉到了和我们相仿的年纪，也做着和我们类似的事情——有为理想的奋斗的激情，有现实中碰钉子的无奈，也有有酒逢知己千杯少的感慨，更有和自己爱人待在一起缠绵，这对从感性上开始对马恩他们两个在我国近似于“符号化”存在的人物真正地了解，真的是太重要了。</p><p>最后，我觉得电影的确还缺乏一些对马克思思想令人深思的阐述。它讲述了马克思的成长历程，但却没有讲述出马克思思想的成长历程。比如影片用挺久时间讲述了马克思用《哲学的贫困》来反驳蒲鲁东《贫困的哲学》，我们得到的也只有他反驳蒲鲁东关于他的无政府主义，我们却始终没有听到具体反驳的声音到底在哪里。最后片中大声朗读《共产党宣言》中的内容，但是我相信多数人只是感觉热血沸腾，却不知其中平实语言中蕴含的深刻哲理。不过马克思思想的确庞杂而繁杂，不能对一个两个小时的电影求全责备，能讲出这些，已经很不容易了。</p><hr><p>电影中的一些桥段也十分精彩。</p><p>开场像一幅浓墨重彩的油画，很有欧洲片的感觉。场景是许多德国穷人在携家带口捡树上脱落的枯枝。然后警察就突然出现，穷人被他们无辜杀害驱逐抓捕。毫无疑问，这里是说马克思在大学刚毕业去莱茵报工作时期对《林木盗窃法》进行批判的事情。所以画面一转，就是马克思对莱茵报许多同事太过软弱的激烈吐槽，而警察开始在楼下围攻莱茵报办公室的场景。</p><p>那时候马克思一直希望用黑格尔的法哲学来批判莱茵省议会的所作所为，但是他的努力失败了，他意识到法律的本源并不是一种绝对精神，而是为了保护某一个阶级的阶级利益，更重要的是，他认识到当时的法律保护的不是人权，而根本上是资产阶级的私有财产。这是他从黑格尔学派转向辨证批判的一个开端，也很可能是“经济基础决定上层建筑”这一说法在思想上的一个开端。那时候的马克思应该和我们年岁相仿，二十三四岁的样子，对法律却有如此深刻的洞悉，我认为他不仅仅是“千古第一思想家”，他更是一位少年天才！</p><p>当然，这件事情的后果是《莱茵报》最终被查封，他和同伴们也去监狱反省人生，不久，他也将和刚成婚不久地妻子燕妮将前往巴黎，也会认识他一生的挚友恩格斯。</p><p>电影对马克思和燕妮的感情以及恩格斯和玛丽的感情都表达得也很到位，燕妮和玛丽在影片里不是一个很平很脸谱化的配角，而是两个活生生的女主。</p><p>燕妮生于贵族家庭，她受够了所在阶级的腐朽生活，抵抗住了来自各方的压力和马克思相爱，结婚。在当时贵族阶级还在享受生活的时候，她已经有如此感悟，可见她的思想境界一定非同寻常女性所能及。马克思也说，她一直是他思想灵感的重要来源。</p><p>在她和马克思刚结婚的时候，他们在家中打闹、斗嘴，到最后接吻、相拥而眠时候的场景让我印象深刻。说实话，以前我也从来没有想过（哪怕是一丝）他们俩之间的生活究竟是什么样的，但这一场景让我彻底明白，他们这对模范夫妇和一般小情侣的日常生活也没有太大的区别，让他们的爱情如此深刻的原因在于他们共同的理想和克服困难的斗志——随后，我便见证了这些。</p><p>第一次是她开玩笑给马恩合著的书取名叫《对批判的批判所做的批判》，后来这本书被命名为《神圣家族》，而副标题正是燕妮所起的《对批判的批判所做的批判》。可见她也是很有哲学思想，甚至是能和马克思探讨很多东西的。第二次是她几次在马克思被驱逐或者拿不到稿费饥寒交迫的时候毫无怨言，甚至在如此艰苦的条件下还成为了好几个孩子的母亲。如果没有满腔的革命热情和对马克思深沉的爱，她怎么能够如此地坚强。不过马克思也并非撇下孩子老婆不管的人，他也以同样的热情为这个家得以维继四处奔波，甚至答应了放弃写作并且低声下气做任何工作（然而他还是没有成功找到一份工作）。这些场景也让马克思的形象更加饱满，他也是和我们一样，为家庭为生计烦扰奔波的普通人。</p><p>玛丽也同样为恩格斯地事业做出了不可磨灭的贡献。恩格斯是一个“富二代”公子哥，但他却不想继承他父亲的衣钵，而是非常同情英国工人的状况，希望可以帮他们说话。所以他前往英国大大小小的工厂进行社会调查，但是由于他身份特殊，许多工人并不待见他。而玛丽帮助恩格斯联系了许多工厂中的工人，才使得他完成了《英国工人阶级状况》这一调查报告。后来她又促成了马恩同正义者同盟的领导者的见面，间接推动了《共产党宣言》的创作与发表。</p><p>马克思和恩格斯的友情也是片中也被着重呈现。片中用欲扬先抑而且有一些无厘头感的镜头把他们从相识到熟悉的经历表现出来。</p><p>马克思先是因为恩格斯代表的资产阶级而看不上他，但是当他们聊起天来的时候，甚是忘我，马克思居然都忘记他们是要去讨稿费才见的面。再之后，他们一起逃离法国警察追捕又相遇的镜头像极了一部小型警匪片，就像他俩是认识了多年的老搭档一样，在一路东躲西藏之后，又在一个隐秘的转角重新相逢，然后像没事儿人一样一起去喝酒。</p><p>在开怀大醉之后，马克思说出了那句令我震动的话：“哲学家们都在解释世界，而问题在于改变世界！”两位前辈就从这句话出发，一步一步地对这个世界进行剖析，并且将他们的一生贡献给了世界无产阶级的解放事业中去。</p><p>在后面的相处中，马克思是一个性格如火一般富有斗争热情又很有思想的角色，而恩格斯则显得内敛许多，他俩在性格上非常互补，成为了非常合适的搭档。特别是在最后由恩格斯拿着马克思的手稿主导正义者同盟的“改名大会”的时候，恩格斯不断呼吁寻求更多支持，马克思则火药味十足，他们两人配合，终于让《共产党宣言》成为了共产主义者同盟的行动纲领。<br>影片最后，马恩两家在海边度假，马克思说因为琐事太多，而且经济困难，所以没法写一部大部头的书，而且生活太累的时候，恩格斯说，欧洲的革命已经开始，资产阶级专制统治已经非常脆弱，各地的工人运动已经风起云涌，工人阶级将会自醒，解放事业可能很快就会成功。 </p><p>这让我从电影中跳出来，想到了之后发生的事情，令人唏嘘不已——直到马克思死后，世界上第一个社会主义国家苏联才建立，而直到两百年后的今天，世界仍处于资本主义的笼罩之下，而现在的资本也披上了金融这层看似温和的外衣。 </p><p>片中没有花很大笔墨介绍马克思同蒲鲁东的论战，而用很多镜头表现了他与魏特林的冲突。 </p><p>魏特林也是当时工人阶级的代表者，主张是“人人皆兄弟”，并且企图用这个口号和富有激情的演讲来感动所有人从而实现革命。但是魏特林的思想却还非常不成熟，他没有意识到冲突的根本是阶级斗争，所以非常反对马克思这种在他看来很形而上的“纲领”，而他所讲的仁慈博爱这种对工人运动毫无意义的词汇也让马克思反感。终于有一次会议上马克思爆发，正式和魏特林决裂。 </p><p>之后，在正义者同盟那位有智慧的老者的支持下，同盟最终站在了马克思这边，并同意马恩一起起草一份纲领性的宣言——《共产党宣言》。 </p><p>很多人应该都记得魏特林反驳马克思的这句名言：“批判会吞噬一切存在，当没有其他东西可吞噬的时候，它就只能吞噬它自己。”他显然认为这里的批判就是黑格尔学派所说的批判，因为但是黑格尔学派的一些人主张对一些哲学家的批判进行再次的批判，所以他认为当他们把旧的东西批判干净的时候，只能再次批判批判过旧的事物的批判了。不过他没有理解马克思所认识到的批判是什么意思。他如果认真读了当时马恩所写的《神圣家族》以及《德意志意识形态》，就会明白当时在他们面前说的这句话是很幼稚的。</p><hr><p>回想电影中的马克思，他对事业执着，对工作勤劳、对妻子挚爱，对家庭有责任心，对朋友真诚。他作为一个学者，把人性的真善美演绎得淋漓尽致。片中还没讲，他为了写成《资本论》，在大英图书馆中一坐就是几十年。 </p><p>再看看我们当下的学者，他们中有很大一部分人做事情的并不是潜心的研究，也并没有什么对未来的理想，而当下这个时代，他们最喜欢做的事情就是疯狂地“捞钱”。更令人不齿的是，最近全国接二连三出现多起类似导师让学生叫“爸爸”，导师性侵女学生的案件，这些都无不令人唏嘘。 </p><p>我认为马克思不仅为我们留下了几厚本文字作为遗产，他的勤勉好学，他的敢爱敢恨，他的崇高理想，也需要当下青年学生、学者们多去反思和学习。 </p><p>更可怕的一件事情是马克思被符号化。从我们小学开始，就一直在听这两个大胡子老头的事迹，知道他们是好友，知道他们的思想非常厉害，对我们现在的社会影响深远。却又觉得他们十分遥远，不知他们究竟是什么样的人，更不知道他们的思想究竟是何物。 </p><p>伴随着许多人对现实的不满，又受到西方意识形态的强烈灌输，以及他们从中学课本的只言片语出发所产生的对整个社会的片面的思考，许多人开始批评这两位老人，厌恶这两位老人，甚至诋毁这两位老人。看完电影以后我翻了翻豆瓣的影评，充满戾气。 </p><p>除去头脑中的偏见，要从感性的认识开始。我想，这些人更应该去看看这部电影，去了解他们的生活，他们的思想，认识一个不再符号化的马恩。所以从这个角度来看，电影之所以没有提及那么多的马克思的思想，也是因为它为大众所准备的，可以让观众从能理解的角度认识这个活生生的马克思。 </p><p>我想，看到电影中 18 世纪英国工人们被榨取剩余价值的惨烈场景，看到资产阶级警察们对无产阶级的草菅人命，不会有人还认为这个斗争是毫无价值的吧？如果没有工人阶级的运动，没有那么多人流血牺牲，现在的欧洲还会是当时的那个欧洲。不要再说什么现在生产力强大了，资本家就不会压迫工人了。影片中一位工厂主的话告诉我们：如果你不雇佣童工，如果不压迫工人，会有其他人为了获取更多的利益这么做，那么社会必要劳动时间会减少，产品的价值会下降，如果你不去这么做，你就会面临成本的上升，你就会破产。工人生产的产品越多，生产越快，那么他自己的价值却越低。别说这个规律只在那个时候起作用，在现在这个时代，对于各行各业，也都是完全一样的。 </p><p>现在我们身在“高大上”的互联网公司，拿着看起来挺高的薪水，但是人人不还是在没日没夜每周末像机器一样的 996 中度过，你所创造的价值，到底又有多少归你所有了呢？</p><p>当下依旧是技术与资本的时代，只是资本披上了另一层温和一些的外衣。所以并不是现在马克思思想已经过时了，马克思主义仍是当下的一个幽灵，始终盘旋在我们这个资本主义世界上空。也正是因为有了这一柄达摩克里斯之剑，才使得现在的资本主义变得温和，让我们无产者在被资本支配的同时，也可以享受到资本所带来的生产力的提升而产生的富足而美好的物质生活。 </p><p>所以，电影中的这两位主角，的的确确是如此的伟大。 </p><p>另一个角度去向，当资本发展到今天，以如此这般更加猖獗更加繁荣的面孔出现，这不更是一个从未有过的最好的研究和发展马克思主义思想的历史时期么？ </p><p>另外还想做两点科普。 </p><p>第一，马克思不是经济学家。《资本论》的副标题是《政治经济学批判》，他是在用以辩证法为核心的新的叫做批判的科学来对经济学进行批判。所以虽然马克思在经济学领域有很深的造诣，（也正因为他如此了解经济学）他却做了对经济学（确切说也不能是经济学，而是对当下现实）最的深刻批判。这门新的科学也可以运用在其他的领域，只是马克思去世太早，还没有精力把这把利剑插向别的范畴。 </p><p>第二，马克思所谓的共产主义，也并不是所有的东西都是公有制，不允许个人拥有一分一毫的个人物品。这里的共产指的是扬弃经济学中的资本，让所有物不再以私有财产的形式出现，而需要公有的是人们从事生产活动所需要的生产资料。许多人甚至认为共产主义连婚姻都要”共享“，这是多大的谬误。 </p><p>PS：拖延了一周终于按照之前所列的大纲基本写完了。对于马克思思想，我也只知皮毛，有很多想不清楚，没弄懂的地方。所以如果大家发现文中存在谬误，希望可以批评指正。 </p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="http://music.163.com/song/media/outer/url?id=26961953.mp3"></iframe>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近得知《青年马克思》上映，觉得有必要一看。于是上网搜了一下院线的排片，不出所料，排片量几乎是最近热映的《复联 3》的五分之一，甚至周末都少有商业影院有排期。于是只能等到周一约上阿文，去附近的影院一睹青年时期马克思的“芳容”。&lt;/p&gt;
&lt;p&gt;刚入座，还在和朋友聊最近的中兴联想发生的一系列事件，电影就毫无防备地开始了。此时一个大概容纳五六十人的小影厅里只稀疏地坐着六七个人，多数还是学生（祖国未来还是很有希望的嘛）。&lt;/p&gt;
&lt;p&gt;电影里的场景暂且不表，先来说说我对电影整体的感受吧。 首先，作为一部传记电影，而且讲述的是一位思想家的成长历程，如果没有一些对马克思生平以及思想的了解，可能就会在电影院呼呼大睡了。这可能会是观影的一个门槛。&lt;/p&gt;
&lt;p&gt;其次，电影内容很丰富。短短不到两个小时，电影讲述了马克思从莱茵报编辑，到论战蒲鲁东，最后是完成《共产党宣言》这三个时期，同时又穿插了马克思与燕妮之间深沉的爱，马克思同恩格斯之间深切的友谊以及恩格斯同玛丽之间跨越阶级的感情。&lt;/p&gt;</summary>
    
    
    
    <category term="影评" scheme="https://blog.zhengi.me/categories/%E5%BD%B1%E8%AF%84/"/>
    
    
    <category term="马克思" scheme="https://blog.zhengi.me/tags/%E9%A9%AC%E5%85%8B%E6%80%9D/"/>
    
    <category term="影评" scheme="https://blog.zhengi.me/tags/%E5%BD%B1%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>使用Webpack-Dev-Server处理跨域请求</title>
    <link href="https://blog.zhengi.me/webpack_dev_server_cors/"/>
    <id>https://blog.zhengi.me/webpack_dev_server_cors/</id>
    <published>2018-04-17T14:56:22.000Z</published>
    <updated>2024-03-23T06:03:16.947Z</updated>
    
    <content type="html"><![CDATA[<p>在前端调试的时候，跨域一直都是一个比较麻烦的问题，这个在之前的文章<a href="https://blog.zhengzi.me/deal_with_cors">关于跨域问题的一个解决方法</a>中其实已经讨论了一些可以使用的方法。</p><p>如果要使用 JSONP，第一是需要修改的地方比较多，而且也不太符合前端发展的大趋势，如果使用 CORS 的话并没有 application/json 类型。而且更重要的是这只是在前端调试时候的需求，并不是在上线以后的需求，所以对后端有太多的入侵也不好。</p><p>所以就有一个念想突然在大脑中闪过——加入有一个代理不就可以解决这个问题了？但是又想了一下写起来还挺麻烦，于是就被搁置了。 直到前几天 Stone 提到其实 webpack-dev-server 早就想到并且已经帮我们实现了。</p><p>于是，我就在一个 Vue 项目中进行测试，发现真的很赞，既可以本地 Server 热加载，还可以直接跨域调用远程 API，完美解决了之前遇到的所有问题。</p><p>接下来我简要介绍一下步骤（以一个 Vue 脚手架建立的 webpack 项目为例）：首先检查<code>build/webpack.dev.conf.js</code>中是否有</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy: config<span class="selector-class">.dev</span><span class="selector-class">.proxyTable</span>,</span><br></pre></td></tr></table></figure><span id="more"></span><p>这个配置项，如果被注释掉，请打开注释，如果没有，请加入到 devServer 对象中 然后在 <code>config/index.js</code> 中的 dev 对象中加入 proxyTable 配置项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">proxyTable:</span> &#123;</span><br><span class="line">  <span class="string">&#x27;/**&#x27;</span><span class="string">:</span> &#123;</span><br><span class="line">  <span class="attr">target:</span> <span class="string">&#x27;http://api.xxx.com&#x27;</span>,</span><br><span class="line">  <span class="attr">changeOrigin:</span> <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">secure:</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="string">,</span></span><br></pre></td></tr></table></figure><p>前面的键 <code>/**</code> 意思是代理所有请求，如果代理某些请求，可以将其改为诸如 <code>/api</code> 之类的字符串。</p><p>后面的 target 就是要代理到的网站，<code>changeOrigin</code> 的意思就是把 http 请求中的 Origin 字段进行变换，在浏览器接收到后端回复的时候，浏览器会以为这是本地请求，而在后端那边会以为是在站内的调用。</p><p>这样，通过这个简单的配置，就完美地解决了跨域的问题。</p><p>之后，在直接运行</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="built_in">run</span> dev</span><br></pre></td></tr></table></figure><p>的时候，就可以将测试前端中的 ajax 请求代理到后端服务器进行测试啦！</p><p>最后，贴上官方文档，具体的配置大家可以参考这里：<br><a href="https://webpack.js.org/configuration/dev-server/#devserver-proxy">https://webpack.js.org/configuration/dev-server/#devserver-proxy</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在前端调试的时候，跨域一直都是一个比较麻烦的问题，这个在之前的文章&lt;a href=&quot;https://blog.zhengzi.me/deal_with_cors&quot;&gt;关于跨域问题的一个解决方法&lt;/a&gt;中其实已经讨论了一些可以使用的方法。&lt;/p&gt;
&lt;p&gt;如果要使用 JSONP，第一是需要修改的地方比较多，而且也不太符合前端发展的大趋势，如果使用 CORS 的话并没有 application/json 类型。而且更重要的是这只是在前端调试时候的需求，并不是在上线以后的需求，所以对后端有太多的入侵也不好。&lt;/p&gt;
&lt;p&gt;所以就有一个念想突然在大脑中闪过——加入有一个代理不就可以解决这个问题了？但是又想了一下写起来还挺麻烦，于是就被搁置了。 直到前几天 Stone 提到其实 webpack-dev-server 早就想到并且已经帮我们实现了。&lt;/p&gt;
&lt;p&gt;于是，我就在一个 Vue 项目中进行测试，发现真的很赞，既可以本地 Server 热加载，还可以直接跨域调用远程 API，完美解决了之前遇到的所有问题。&lt;/p&gt;
&lt;p&gt;接下来我简要介绍一下步骤（以一个 Vue 脚手架建立的 webpack 项目为例）：首先检查&lt;code&gt;build/webpack.dev.conf.js&lt;/code&gt;中是否有&lt;/p&gt;
&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;proxy: config&lt;span class=&quot;selector-class&quot;&gt;.dev&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.proxyTable&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.zhengi.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="JavaScript" scheme="https://blog.zhengi.me/categories/%E6%8A%80%E6%9C%AF/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://blog.zhengi.me/tags/JavaScript/"/>
    
    <category term="跨域" scheme="https://blog.zhengi.me/tags/%E8%B7%A8%E5%9F%9F/"/>
    
    <category term="前端" scheme="https://blog.zhengi.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="WebPack" scheme="https://blog.zhengi.me/tags/WebPack/"/>
    
  </entry>
  
  <entry>
    <title>寻觅意义</title>
    <link href="https://blog.zhengi.me/finding_the_meaning/"/>
    <id>https://blog.zhengi.me/finding_the_meaning/</id>
    <published>2018-03-03T15:36:34.000Z</published>
    <updated>2024-03-23T06:03:16.943Z</updated>
    
    <content type="html"><![CDATA[<p>偶然读到王德峰老师的一本已经绝版的小册子，叫《寻觅意义》。心想这个题目起的甚是有趣——其一我在想他会怎么写，结果读下去发现是他在各个大学讲座的讲稿的一个小集；其二说来也很巧，我最近也一直在反思意义究竟是什么，我做什么才有意义，我追求的意义是什么，有没有属于这个时代的意义，而真正的大义又是何物呢？</p><p>关于时代的意义，和妈妈聊天的时候，她关于她的意义是什么给了我如下的解答：“除了想让你过的开心快乐，剩下的意义就是多赚钱了，钱赚得多，我就感觉很踏实。”我想，前半句是家庭，是我和母亲很真挚的亲情；后半句是时代，是我和母亲以及所有存活于现代社会的人共同处于的环境。</p><p>我们所处的是这样一个被资本与技术所主导的时代。所以我理解大家的理想多是要去赚钱。不论男女老少，不论贫穷富贵，每个人的欲望也总和钱脱不开关系。而钱这个东西，究其根本，不过是一个几乎是全人类共同参与的一个游戏，同我们的能生存与否没有什么直接的依赖关系，只是在这个时代里，我们需要用钱去获得各种生存资源和对他人支配的权力。</p><span id="more"></span><p>所以与其说我们想去赚钱，不如说是这个时代规定了我们想要的是去赚钱。</p><p>然而，赚到再多的钱又有什么意义呢？大家拼命多赚钱，最后又能得到什么呢？许多富人甚至比穷人还要忙还要苦恼，他们赚了这么多钱，但是赚到了意义么？</p><p>是，赚到钱越多，我们可以获得的社会资源也就越多，可但是钱作为一个可以被数的数字，一个人究其一生，能获得的量总还是有限的。但是人心呢？</p><p>一个人可以在史书中穿越到几百年之前，可以在对未来的幻想中穿越到几千年后，甚至可以在对宇宙思考中时间横亘数百亿年。人不论活在哪个时间点，总可以在头脑中对过去和未来作出无限的延拓。所谓人心，是无限的。</p><p>倘若有钱的金钱来对无限的生命说：我就是你的意义！这句话还会成立么？</p><p>既然金钱的意义是仅对于我们这个时代的，而且对于无限生命来说，它也太微不足道了些，那意义，能够称得起对于生命有意义的东西，究竟是什么呢？</p><p>在很长的一段时间里，我曾认为它是宇宙的终极真理。就是随着以物理学为首的近代科学的不断深入探究，我们总能得到一个越来越接近宇宙真相的真理。</p><p>但是随着这条线仔细深入想下去，结果却令我失望。就举一个物理学的例子：在这一秒钟苹果从树上掉到了地上，牛顿说它是受到了重力的作用，好，那么请证明，在下一秒钟，还是会有苹果会受到重力落到地上。对于休谟的这个诘难，近代科学还无法解答。我们能说的只是：根据这么多年的人类观察历史，所有的事实皆是如此，所以我相信它会继续下落。</p><p>所以从根源上来讲，我们所坚信的自然科学，都是经验的产物。经验总有被打破的时候，那么我们通过经验所找到的这些自然科学的定理，是真的真理么？</p><p>我们所掌握的这些科学，倒是为我们控制其它事物提供了许许多多行之有效的方法，可以满足人类许许多多的需求，给资本帮了一个大忙。所以，科学主义，是西方近代理性形而上学的延伸，是笼罩在当代的一种意识形态，它的真理，是基于经验而派生出来的。</p><p>唉，通过科学的方法来寻找宇宙终极真理的路，在这里就完全被堵住了。</p><p>既然已经在我们外部探究了这么多，寻找意义却依然没有结果，如果转向我们自身，我们内部，又会怎样呢？</p><p>我不知道我成长了这二十多岁，已经被这个时代这个世界改变了多少，还依然保留了多少被许多前辈们所诟病的不成熟的“童心”呢？</p><p>我想，爱情算是其一，也需要被放在首位。</p><p>在爱情里面我相信命运，另一半不需要用什么物质上的可列举条件标准来衡量，需要做的是去等待。对的人可能就是上辈子所注定的，互相相处一段时间，甚至是交换一个眼神，那种爱情的感觉就来了，是一种无法欺骗内心的感觉，就可以确定——就是她！</p><p>而缘分呢，感觉就很像佛教中所讲的业。两个人上一世造的业（当然是善业），就像一颗种子一样，不断成长发芽，在这一世，你们就回彼此相遇，由你们共同来完成这一世的存在。当然，你也要在这一世需要珍惜且付诸行动，才能让前世所积攒的被白白消耗。</p><p>另外，在爱情中我也像“傻了一般”，并不会理性地计算得失。因为计算得失是商人相处时要去做的事情，跟恋人去计算，我的内心会有极大的阻力和抵触。</p><p>在爱情中，我可以感受到一种真实感，一种真真实实存在的，爱与被爱的感受，而非虚无的外物与金钱所能比拟的。</p><p>另一个是随着思考理解的深入才认识到的，就是艺术。</p><p>最开始醍醐灌顶般明白过来是因为看到了海德格尔的一句话：“艺术是真理的原始发生”。我就在想，为什么是艺术，而不是科学，成为了那个最朴素的真理？</p><p>相似的话尼采也说过：“人在事物中除了重新发现自己的入藏品而外再不会重新发现任何东西——这种再发现，自称科学。入藏品包括艺术、宗教、爱、自豪。”他也提到了科学的派生性，而真理来源于艺术、宗教与爱。</p><p>如王老师在小册子里所说的，艺术其实就是巫术。</p><p>古代人对于巫术，并不是在举行完仪式以后，就什么都不去做了，等着上天的恩赐，而是在仪式完成以后，大家要一起去完成一个凶险困难或对生死存亡意义重大的事情，比如大型狩猎、建造、以及秋收。通过巫术，让集体中的每个人凝结在一起，也给了人类以未来。</p><p>为什么会这样？我认为这是由于我们每个人可以理解超验的超自然的事物的存在（比如艺术中的感情、宗教中的神明，甚至是一个国家、一个政党，人们的品格、信念、爱情，更甚至是某个虚构的人格，比如超人，或者是。。。王尼玛）。</p><p>而从古至今的诗歌、音乐以及画作等等艺术，都是有此作用。这些艺术作品将人类对某种事物的情感封存在其中，当人们再看到这件作品的时候就可以激发出他们对于情感的共鸣和他们对超验世界共同的认识与体会。</p><p>是雕塑艺术让人们真正理解到了石料的存在，否则它们就是一堆用作建筑的物质，是音乐让人们真正理解到了声音的存在，否则它只是一种可以用来传递信息的波（虽然我们每天都通过声音收发了许多信息，却只有音乐能让我们听到真正的声音，这种对于人的感性的存在），绘画也是如此，让我们看到了光线真正的存在，否则它也只是一堆电磁波（然而电磁波也是我们描述它的一个方式，它真正的存在是什么呢，或许只有在绘画中才能真正表现出来）。</p><p>让人领悟到物质的感性存在或许就是艺术的伟大之处。</p><p>成年人向外部索取太多，而对内部听到的却越来越少，这大概就是孟子所说的“失其本心”吧。在这个只认金钱，意义丢失的时代，我想，不能害怕在时代的荒原中和多数人走上了不同的方向，要回到自己的内心，去真心体验人最真挚的情感，寻找绿洲的存在。说不定，就找到了那一片属于自己的绿洲了呢？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;偶然读到王德峰老师的一本已经绝版的小册子，叫《寻觅意义》。心想这个题目起的甚是有趣——其一我在想他会怎么写，结果读下去发现是他在各个大学讲座的讲稿的一个小集；其二说来也很巧，我最近也一直在反思意义究竟是什么，我做什么才有意义，我追求的意义是什么，有没有属于这个时代的意义，而真正的大义又是何物呢？&lt;/p&gt;
&lt;p&gt;关于时代的意义，和妈妈聊天的时候，她关于她的意义是什么给了我如下的解答：“除了想让你过的开心快乐，剩下的意义就是多赚钱了，钱赚得多，我就感觉很踏实。”我想，前半句是家庭，是我和母亲很真挚的亲情；后半句是时代，是我和母亲以及所有存活于现代社会的人共同处于的环境。&lt;/p&gt;
&lt;p&gt;我们所处的是这样一个被资本与技术所主导的时代。所以我理解大家的理想多是要去赚钱。不论男女老少，不论贫穷富贵，每个人的欲望也总和钱脱不开关系。而钱这个东西，究其根本，不过是一个几乎是全人类共同参与的一个游戏，同我们的能生存与否没有什么直接的依赖关系，只是在这个时代里，我们需要用钱去获得各种生存资源和对他人支配的权力。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://blog.zhengi.me/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="哲思" scheme="https://blog.zhengi.me/categories/%E9%9A%8F%E7%AC%94/%E5%93%B2%E6%80%9D/"/>
    
    
    <category term="意义" scheme="https://blog.zhengi.me/tags/%E6%84%8F%E4%B9%89/"/>
    
    <category term="哲思" scheme="https://blog.zhengi.me/tags/%E5%93%B2%E6%80%9D/"/>
    
  </entry>
  
  <entry>
    <title>年关随笔</title>
    <link href="https://blog.zhengi.me/feelings_around_new_year/"/>
    <id>https://blog.zhengi.me/feelings_around_new_year/</id>
    <published>2018-02-14T17:44:09.000Z</published>
    <updated>2024-03-23T06:03:16.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深度写作"><a href="#深度写作" class="headerlink" title="深度写作"></a>深度写作</h1><p>最近看见沈向洋发表了一篇文章（地址：<a href="https://zhuanlan.zhihu.com/p/33771188">https://zhuanlan.zhihu.com/p/33771188</a>），大意是说在这个 AI 的时代，虽然每天我们产生和接受的的零碎的信息量都非常巨大，但真正有意义的思考还是需要通过长篇写作来完成。写作可以帮我们理清思绪，可以清晰地表达观点和逻辑。</p><p>这也是我最近所担心的事情——我也已经很久没有进行过深度的写作了。</p><p>上次系统地写作还是中外文学名著鉴赏的期末作业，文章虽然可以大致表达我想说的表面意思，但是短短八百字的表达却支离破碎，根本无法把我更深成次的想法完整表述出来。在刚写完的时候没感觉到还沾沾自喜，觉得一下午写出来的文章应该还能看，之后读起来却就像是读一篇小学生记的流水账一般，像是喝了一大杯白开水还泛着水垢一般，毫无深度，甚至还难以读完。</p><p>感触更深的一次是上个月我想抽空写一下去年的年终总结，但刚提笔就不知道该从何说起，所以又去翻前几年的文章，发现当时的文风根本现在几乎无法模仿。我十分懊恼，故总结也一直搁置下去。</p><p>直到今天，我才有勇气重新打开编辑器开始写这篇文章。今天没有给文章定下主题，想到哪里就写哪里，但愿思路会更顺一些吧。</p><span id="more"></span><h1 id="活着"><a href="#活着" class="headerlink" title="活着"></a>活着</h1><p>正如认识存在需要通过感受虚无一样。认知活着也需要感受死亡。</p><p>这个假期的前半段就是虚无与死亡。虽然之前在各种文艺作品中已经见过了无数种死亡的情景，但自己有如此深的感受到却还是第一次——这次死亡的对象不再是文学作品中或者和自己关系不大的某个人，而是我打小就十分亲近的奶奶。</p><p>思绪回到寒假之前，刚听闻奶奶住院的消息时，虽然奶奶声音听起来依然慈祥有力，但了解病情后，我十分担忧，感觉就像是一块石头压在心头，怎么都喘不过气，每天晚上能见到的只有噩梦。果不其然，第二次我再打电话过去的时候，奶奶的声音已经有些孱弱，听起来也很是疲惫。</p><p>第二天一大早，姑姑给我发的信息只有几个字：能提前回来就提前回来。于是当天就提前请假、买高铁票、交接任务、安排事情、准备回家。我记得当天中午和卤蛋同学一起吃饭，有好几次我都集中不了注意力，大脑里的各种思绪像幻灯片一样飞快地闪过，却怎么也提炼不出头绪来。</p><p>回家后就径直到了奶奶住的医院，趁着奶奶比较清醒的时候，同奶奶讲了几句话，还给她看了前两天和卤蛋一起专门给她拍的合影，看得出奶奶当时还挺开心。现在我很感激当时的我所做的这个决定，这几句话大概是和奶奶最后一段完整的对话了。</p><p>之后几日，奶奶的身体情况一日不如一日，死神在不断地靠近这个历经近八十年岁月洗礼为家庭为儿孙操劳无数的坚强的女人。我知道，任何手段都无法阻止死神来临的脚步，能做的就是默默等待，当你一不留神，他就会悄无声息地到来。经过几天痛苦的思考，我想，我已经足够坚强，可以接受这个事实。另外，看着奶奶在病床上受苦的样子，有时候我也竟盼着死神早些光顾，她这辈子已经受了太多的苦，能让她早日解脱也未尝不是好事。</p><p>2 月 6 日晚上，奶奶情况突然恶化。奶奶弥留之际，爷爷放下多少年来和奶奶的吵吵闹闹，开始和奶奶讲心里话。虽然没有一个“爱”字，但句句都是直戳心灵的情话。这时我才知道，在无数的吵吵闹闹的背后，他们老两口之间更多的是无法用言语表达的爱和包容，才能一起走过这近六十年的风风雨雨。我当时就在想：这老爷子，干嘛就那么犟那么固执，非要到了这个时候才把这些心里话说出来呢，这可是我听过的世界上最动听的情话！可惜不知那时的奶奶究竟还能不能听到。</p><p>终于，在 2017 年 2 月 7 日凌晨 3 点 41 分，死神终于悄悄出现在我们身边，带走了这个在世上受尽苦难但又善良而伟大的灵魂。奶奶生前是基督徒，按照教义，她已经为世人受了太多罪过，我相信她的灵魂一定会上天堂，和主耶稣永永远远生活在一起，再也没有烦扰，再也没有痛苦。</p><p>此后几日，为奶奶守灵。爷爷奶奶的许多朋友都自行前来吊唁。跟他们聊起来，听他们讲起当年的故事，我才体会到能和爷爷奶奶做朋友的人，也都有着属于他们那个年代的诚实、正直、热心和血气方刚。说起他们的很多事迹，许多自诩深谙社会之道的人，甚至是现在刚成年的许多零零后们，都一定无法理解。这些爷爷奶奶，一生归来后，也仍是少年。</p><p>葬礼后，我像是突然醒悟似的，意识到奶奶的的确确，永远离开了我们。回家后，我有时候还是幻想她还在，还在厨房里忙忙碌碌准备我最爱吃的饭菜，还在用她歪歪扭扭新学到的字抄写歌词，还在那台跟她一起度过了几十年的缝纫机上缝缝补补。直到今天，在超市见到一个盒子的时候，我还是会下意识地说道：买上这个可以给奶奶盛放阵线用。接着才想到，她现在在天国，应该已经用不到针线盒了吧。</p><p>最后，借用《无问西东》中的一句话：逝者已矣，生者如斯。</p><p>在以后的日子里，应该收起悲伤，努力坚强地活下去，要更加好好对待自己所爱之人，如果爱她，就一定要大声地告诉她。这一定是奶奶也天堂所希望看见的。</p><h1 id="情人节"><a href="#情人节" class="headerlink" title="情人节"></a>情人节</h1><p>卤蛋同学，今天是我们一起度过的第一个情人节。很巧，也是我们在一起的第 214 天。</p><p>和你在一起的这大半年里，每每想到你，我的嘴角都会露出微笑，每每拥抱你，我的内心都感到无比幸福。和你在一起，总有说不完的话，谈不完的心，也有逛不完的商场和公园。</p><p>你我从相识到相知再到相爱，每一步都像是上帝安排好的，十分自然地铺在我们面前，但又留下了许许多多值得我们回味的故事。</p><p>卤蛋，我爱你，就像爱生命。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;深度写作&quot;&gt;&lt;a href=&quot;#深度写作&quot; class=&quot;headerlink&quot; title=&quot;深度写作&quot;&gt;&lt;/a&gt;深度写作&lt;/h1&gt;&lt;p&gt;最近看见沈向洋发表了一篇文章（地址：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33771188&quot;&gt;https://zhuanlan.zhihu.com/p/33771188&lt;/a&gt;），大意是说在这个 AI 的时代，虽然每天我们产生和接受的的零碎的信息量都非常巨大，但真正有意义的思考还是需要通过长篇写作来完成。写作可以帮我们理清思绪，可以清晰地表达观点和逻辑。&lt;/p&gt;
&lt;p&gt;这也是我最近所担心的事情——我也已经很久没有进行过深度的写作了。&lt;/p&gt;
&lt;p&gt;上次系统地写作还是中外文学名著鉴赏的期末作业，文章虽然可以大致表达我想说的表面意思，但是短短八百字的表达却支离破碎，根本无法把我更深成次的想法完整表述出来。在刚写完的时候没感觉到还沾沾自喜，觉得一下午写出来的文章应该还能看，之后读起来却就像是读一篇小学生记的流水账一般，像是喝了一大杯白开水还泛着水垢一般，毫无深度，甚至还难以读完。&lt;/p&gt;
&lt;p&gt;感触更深的一次是上个月我想抽空写一下去年的年终总结，但刚提笔就不知道该从何说起，所以又去翻前几年的文章，发现当时的文风根本现在几乎无法模仿。我十分懊恼，故总结也一直搁置下去。&lt;/p&gt;
&lt;p&gt;直到今天，我才有勇气重新打开编辑器开始写这篇文章。今天没有给文章定下主题，想到哪里就写哪里，但愿思路会更顺一些吧。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://blog.zhengi.me/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="年终总结" scheme="https://blog.zhengi.me/categories/%E9%9A%8F%E7%AC%94/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="年终总结" scheme="https://blog.zhengi.me/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>使用c++和XAML开发UWP程序</title>
    <link href="https://blog.zhengi.me/cpp_xaml_uwp/"/>
    <id>https://blog.zhengi.me/cpp_xaml_uwp/</id>
    <published>2017-10-24T09:30:54.000Z</published>
    <updated>2024-03-23T06:03:16.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Windows-桌面程序开发一些方案"><a href="#Windows-桌面程序开发一些方案" class="headerlink" title="Windows 桌面程序开发一些方案"></a>Windows 桌面程序开发一些方案</h1><p>开发 Windows GUI 程序的方案有很多，接触过比较流行的大概有三种，一种是 C++和 Qt，一种是 HTML5+浏览器内核，最后一种是 C#+WPF。另外古老的 WinForms 和更古老的 MFC 也不多说了。</p><p>Qt 的跨平台特性得以开发的项目可以跨平台，而且各种 C++的组件非常丰富。但是但是 Qt 本身库的并不小，我也不是很喜欢 QML 那种 JSON 的书写方式，而且 Qt Creator 用起来也不太顺手，所以一般没怎么用过这种开发模式进行桌面应用的开发。</p><p>H5 和浏览器内核是一个不错的方式，可以轻松跨平台，而且 H5+JS 可以有很快的开发速度。主流的方案有 Electron、nwjs、cef 和 wke（其中<a href="http://www.danmakupie.com/">弹幕派</a>所用的方案就是 wke），但是 Electron 同样体积巨大，不利于应用的分发。wke 虽小但也很久没有更新，内核很老，bug 比较多。最近志鹏同学正在研究之前 wke 开发者新开发的 miniblink 内核，相信这个方案会比较优秀。</p><p>WPF 必须依赖于.NetFramework，所以无法跨平台，而且 XP 也不自带.Net，需要用户安装。另外，XAML 虽然写起来麻烦一些，但是开发漂亮的 GUI 还是比较方便。而最新的 UWP 技术也利用了 WPF 的 XAML 进行 UI 的设计，转型起来并不困难。</p><span id="more"></span><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>上周受到卤蛋同学的启发，如果需要使用 C++开发 GUI 程序难道只能用 Qt（或者北邮老师专用的 ege）？能不能使用熟悉的就技术来开发呢？于是在 Windows Dev Center 里找到了使用 C++和 XAML 开发 UWP 程序的方式。粗略看了一下，大概是使用经过微软扩展的 C++，名字叫 c++/cx，基于 Windows RT，但是不受.Net 的托管，也就是要自己处理垃圾回收（这方面理解不够深入，感觉大概是这个意思吧）。</p><p>但不管如何，可以使用 C++和 XAML 开发 Windows 应用还是让人眼前一亮，忍不住去尝试一下。所以，下面开工吧！</p><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>开发环境必须使用 Visual Studio 2017，在新建项目中选择 Visua C++语言的 Windows 通用选项，建立一个空白应用即可。如果没有下载 SDK，上方会提示下载，如果没有显示该选项，说明需要在 VS 安装程序中安装一下 VS 对 C++ UWP 的支持。</p><p><img data-src="/wp-content/uploads/2017/09/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170924163941.png"></p><p>在几秒种后，Visual Studio 就会打开一个新建的应用。假设你对 WPF 很熟悉，你可以看见熟悉的 XAML 设计器，在左侧的解决方案管理器中，也可以看见 C++的文件以代码隐藏文件的形式被嵌在 xaml 文件之后，包含一个.h 文件和一个.cpp 文件。整个工程的组织形式和 WPF 极其相似，这足以让人很激动了。</p><h1 id="开始-Coding"><a href="#开始-Coding" class="headerlink" title="开始 Coding"></a>开始 Coding</h1><p>进一步熟悉一下项目组织形式，可以发现，除了 C++的语法和 C#有区别，开发思路和 WPF 中的 C#是基本一致的，于是对应卤蛋的大作业题目，我建立了一些类的头文件和相关实现，需要注意的是字符串的处理问题，如果要支持中文需要使用 wstring（其实这个问题也并不仅仅是这种时候才会遇到），但关键在于 XAML 中的字符串使用了另外一种并不是 C++标准库中的字符串类型 <code>Platform::String^</code>，所以需要一些函数来在这些字符串中进行转换。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Platform</span><span class="symbol">:</span><span class="symbol">:String^</span> <span class="title class_">Runtime</span><span class="symbol">:</span><span class="symbol">:stops</span>(std::string s)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> ref new <span class="title class_">Platform</span><span class="symbol">:</span><span class="symbol">:String</span>(stows(s).c_str());</span><br><span class="line">&#125;</span><br><span class="line">std::wstring <span class="title class_">Runtime</span><span class="symbol">:</span><span class="symbol">:stows</span>(std::string s)</span><br><span class="line">&#123;</span><br><span class="line">  std::wstring ws;</span><br><span class="line">  ws.assign(s.<span class="keyword">begin</span>(), s.<span class="keyword">end</span>());</span><br><span class="line">  <span class="keyword">return</span> ws;</span><br><span class="line">&#125;</span><br><span class="line">std::string <span class="title class_">Runtime</span><span class="symbol">:</span><span class="symbol">:pstos</span>(<span class="title class_">Platform</span><span class="symbol">:</span><span class="symbol">:String^</span> ps)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> wstos(std::wstring(ps-&gt;<span class="title class_">Data</span>()));</span><br><span class="line">&#125;</span><br><span class="line">std::string <span class="title class_">Runtime</span><span class="symbol">:</span><span class="symbol">:wstos</span>(std::wstring ws)</span><br><span class="line">&#123;</span><br><span class="line">  std::string s;</span><br><span class="line">  s.assign(ws.<span class="keyword">begin</span>(), ws.<span class="keyword">end</span>());</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line">std::wstring <span class="title class_">Runtime</span><span class="symbol">:</span><span class="symbol">:pstows</span>(<span class="title class_">Platform</span><span class="symbol">:</span><span class="symbol">:String^</span> ps) &#123;</span><br><span class="line">  <span class="keyword">return</span> std::wstring(ps-&gt;<span class="title class_">Data</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Platform</span><span class="symbol">:</span><span class="symbol">:String^</span> <span class="title class_">Runtime</span><span class="symbol">:</span><span class="symbol">:wstops</span>(std::wstring ws) &#123;</span><br><span class="line">  <span class="keyword">return</span> ref new <span class="title class_">Platform</span><span class="symbol">:</span><span class="symbol">:String</span>(ws.c_str());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体转换关系可以参考下图，图片来自<a href="http://www.cnblogs.com/nio-nio/p/3511843.html">http://www.cnblogs.com/nio-nio/p/3511843.html</a></p><p><img data-src="/wp-content/uploads/2017/09/4f5f2392683c3f7111fe8c8f6adf7bdd.png"></p><p>在完成对底层数据对象的抽象以后，就可以着手设计界面和应用逻辑了。UI 的设计因为使用了 XAML，所以非常简单，所有的 XAML 特性都可以使用。而 UI 的事件绑定也和 C#非常类似，如果让 Vs 自动生成事件响应程序的话，它会在代码隐藏文件的头文件和实现文件中分别生成函数的声明和函数体，然后就可以直接在函数中写代码来控制它了。</p><h1 id="简单的尝试"><a href="#简单的尝试" class="headerlink" title="简单的尝试"></a>简单的尝试</h1><h2 id="页面导航"><a href="#页面导航" class="headerlink" title="页面导航"></a>页面导航</h2><p>首先说页面的导航，这里和 UWP 的概念非常吻合，只需要一行代码就可以实现。比如我现在需要导航到 UserPage.xaml，我只需要：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Frame</span>-&gt;<span class="type">Navigate</span>(<span class="type">UserPage</span>::typeid);</span><br></pre></td></tr></table></figure><p>就可以完成，有一点需要提醒的就是必须在.h 文件中引入 <code>UserPage.xaml.h</code> 才可以这样调用。</p><h2 id="获取事件触发者"><a href="#获取事件触发者" class="headerlink" title="获取事件触发者"></a>获取事件触发者</h2><p>获取事件触发者也很容易，和 C#中思路相当，事件委托的 Handler 中触发者和参数会被以 sender 和 e 的形式传入，只需要做一些类型转换就可以获得到，下面是一个例子：</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void App1::QuestionListPage::OnPointerPressed(Platform::Object ^sender, Windows::UI::Xaml::Input::PointerRoutedEventArgs ^e)</span><br><span class="line">&#123;</span><br><span class="line">  StackPanel^ s = safe_cast&lt;StackPanel^&gt;(sender);</span><br><span class="line">  <span class="keyword">int</span> questionId =_wtoi(QA::Runtime::pstows( s-&gt;Name).c_str());</span><br><span class="line">  QA::Runtime::currentQuestion = QA::Runtime::questionList[questionId];</span><br><span class="line">  Frame-&gt;Navigate(QuestionPage::typeid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生成-XAML-元素"><a href="#生成-XAML-元素" class="headerlink" title="生成 XAML 元素"></a>生成 XAML 元素</h2><p>不多说，直接贴上代码：</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">QuestionListPage::QuestionListPage()</span><br><span class="line">&#123;</span><br><span class="line">  InitializeComponent();</span><br><span class="line">  vector&lt;QA::Question*&gt;::iterator iter;</span><br><span class="line">  <span class="keyword">for</span> (iter = QA::Runtime::questionList.begin(); iter != QA::Runtime::questionList.end(); iter++) &#123;</span><br><span class="line">    auto questionStack = ref <span class="keyword">new</span> StackPanel();</span><br><span class="line">    QA::Question *question = *iter;</span><br><span class="line">    auto info = question-&gt;getInfo();</span><br><span class="line">    auto questionTitle = ref <span class="keyword">new</span> TextBlock();</span><br><span class="line">    questionTitle-&gt;Text = L<span class="string">&quot;问题:&quot;</span> + QA::Runtime::wstops(info[<span class="number">0</span>]);</span><br><span class="line">    questionTitle-&gt;FontSize = +<span class="number">30</span>;</span><br><span class="line">    auto userName = ref <span class="keyword">new</span> TextBlock();</span><br><span class="line">    userName-&gt;Text = L<span class="string">&quot;用户：&quot;</span> + QA::Runtime::wstops(QA::Runtime::currentUser-&gt;getUserName());</span><br><span class="line">    questionStack-&gt;Children-&gt;Append(questionTitle);</span><br><span class="line">    questionStack-&gt;Children-&gt;Append(userName);</span><br><span class="line">    questionStack-&gt;Name = question-&gt;getQuestionId().ToString();</span><br><span class="line">    questionStack-&gt;PointerPressed += ref <span class="keyword">new</span> Windows::UI::Xaml::Input::PointerEventHandler(this, &amp;App1::QuestionListPage::OnPointerPressed);</span><br><span class="line">    questionList-&gt;Items-&gt;Append(questionStack);</span><br><span class="line">    QA::Runtime::currentQuestion = question;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码在界面初始化以后动态加载了一个问题列表，其中包含了 Title 和 UserName，并且给 StackPanel 绑定了一个叫做 OnPointerPressed 的事件。（就是之前获取触发者中的代码） 一切都非常简单，不得不说微软已经把 c++/cx 改造得很像 C#了，甚至连委托都被加入了进去。</p><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>最后想说说的就是应用中全局变量的实现。 本程序采用了静态类的方式实现了全局变量和一些基础方法的封装（比如各种字符串转换函数）。只需要把需要全局的变量设置成 static，并且赋予初始值，在需要的时候调用即可。以下是代码中全局的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//classes.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Runtime</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> userNum;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> questionNum;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> answerNum;</span><br><span class="line">  <span class="type">static</span> User *currentUser;</span><br><span class="line">  <span class="type">static</span> Question *currentQuestion;</span><br><span class="line">  <span class="type">static</span> vector&lt;User*&gt; userList;</span><br><span class="line">  <span class="type">static</span> vector&lt;Question*&gt; questionList;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//classes.cpp</span></span><br><span class="line"><span class="type">int</span> Runtime::userNum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> Runtime::questionNum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> Runtime::answerNum = <span class="number">0</span>;</span><br><span class="line">Question *Runtime::currentQuestion = <span class="literal">nullptr</span>;</span><br><span class="line">User *Runtime::currentUser = <span class="literal">nullptr</span>;</span><br><span class="line">vector&lt;User*&gt; Runtime::userList = <span class="built_in">vector</span>&lt;User*&gt;();</span><br><span class="line">vector&lt;Question_&gt; Runtime::questionList = <span class="built_in">vector</span>&lt;Question_&gt;();</span><br></pre></td></tr></table></figure><p>对于全局方法，用法一样，不再赘述。</p><h1 id="可用的资源"><a href="#可用的资源" class="headerlink" title="可用的资源"></a>可用的资源</h1><ul><li>官方介绍：<a href="https://docs.microsoft.com/en-us/windows/uwp/get-started/create-a-basic-windows-10-app-in-cpp">https://docs.microsoft.com/en-us/windows/uwp/get-started/create-a-basic-windows-10-app-in-cpp</a>（目前也只找到了这一篇）</li><li>C++ WinRT 介绍：<a href="https://msdn.microsoft.com/zh-cn/magazine/mt745094">https://msdn.microsoft.com/zh-cn/magazine/mt745094</a></li><li>官方 GitHub 仓库：<a href="https://github.com/Microsoft/Windows-universal-samples/tree/master/Samples">https://github.com/Microsoft/Windows-universal-samples/tree/master/Samples</a>（每个例子的 C++文件夹中都是一些示例，文档有限，这些例子非常珍贵）</li></ul><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>说应用跑不起来是假的，自己写的应用，含着泪都要让它跑起来</p><p><img data-src="/wp-content/uploads/2017/09/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170924172202.png"></p><p>不过仔细思考一下，如果不是必须要用 C++，这种开发方案作用并不很大。首先资料太少，连 MSDN 上面都只能搜到 API，几乎没有任何示例，而社区中也几乎一丁点都见不到对这种方案的讨论，所以如果遇到坑基本只能自己靠经验解决（但如果太大呢），比如研究事件委托怎么写我就研究了半个晚上，没有 API 也没有文档。另外这种方案开发出的应用也只能跑在 Windows10 中，对于老版本的 Windows 和其他系统（感觉 Xarmain 也不会支持这种模式），所以应用范围也很受限。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Windows-桌面程序开发一些方案&quot;&gt;&lt;a href=&quot;#Windows-桌面程序开发一些方案&quot; class=&quot;headerlink&quot; title=&quot;Windows 桌面程序开发一些方案&quot;&gt;&lt;/a&gt;Windows 桌面程序开发一些方案&lt;/h1&gt;&lt;p&gt;开发 Windows GUI 程序的方案有很多，接触过比较流行的大概有三种，一种是 C++和 Qt，一种是 HTML5+浏览器内核，最后一种是 C#+WPF。另外古老的 WinForms 和更古老的 MFC 也不多说了。&lt;/p&gt;
&lt;p&gt;Qt 的跨平台特性得以开发的项目可以跨平台，而且各种 C++的组件非常丰富。但是但是 Qt 本身库的并不小，我也不是很喜欢 QML 那种 JSON 的书写方式，而且 Qt Creator 用起来也不太顺手，所以一般没怎么用过这种开发模式进行桌面应用的开发。&lt;/p&gt;
&lt;p&gt;H5 和浏览器内核是一个不错的方式，可以轻松跨平台，而且 H5+JS 可以有很快的开发速度。主流的方案有 Electron、nwjs、cef 和 wke（其中&lt;a href=&quot;http://www.danmakupie.com/&quot;&gt;弹幕派&lt;/a&gt;所用的方案就是 wke），但是 Electron 同样体积巨大，不利于应用的分发。wke 虽小但也很久没有更新，内核很老，bug 比较多。最近志鹏同学正在研究之前 wke 开发者新开发的 miniblink 内核，相信这个方案会比较优秀。&lt;/p&gt;
&lt;p&gt;WPF 必须依赖于.NetFramework，所以无法跨平台，而且 XP 也不自带.Net，需要用户安装。另外，XAML 虽然写起来麻烦一些，但是开发漂亮的 GUI 还是比较方便。而最新的 UWP 技术也利用了 WPF 的 XAML 进行 UI 的设计，转型起来并不困难。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.zhengi.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="UWP" scheme="https://blog.zhengi.me/categories/%E6%8A%80%E6%9C%AF/UWP/"/>
    
    
    <category term="C++" scheme="https://blog.zhengi.me/tags/C/"/>
    
    <category term="UWP" scheme="https://blog.zhengi.me/tags/UWP/"/>
    
  </entry>
  
  <entry>
    <title>兰州小记</title>
    <link href="https://blog.zhengi.me/about_lanzhou/"/>
    <id>https://blog.zhengi.me/about_lanzhou/</id>
    <published>2017-08-31T15:26:06.000Z</published>
    <updated>2024-03-23T06:03:16.943Z</updated>
    
    <content type="html"><![CDATA[<p>时日已至伏末，先别问秋老虎可不可怕，仅是鼻炎已经足以让我怀疑有一个连的人在想我。</p><p>话归正题，兰州在我心中的形象由两部分，一半像兰州烟上（我最喜欢吉祥兰州硬盒上的那个红色镶金的图案）那样：悠悠兰州，九天揽秀，另一半是爽朗直接，像兰州公交车司机一样，可以跳下车跟出租车对骂。总体来讲，用人来形容就是一个很飘渺但又古朴纯净的三四十岁胡子邋遢瘦削的硬汉。总之，矛盾满满。不过这一点不想展开去说，说说最近在兰州的见闻吧。</p><p>按照惯例，每次回家都要去张掖路逛逛，每次去逛也都盼着能有点什么不一样，但又担心不一样的地方多了我会忘记之前是什么样子。不过到目前为止，我的担心都是多余的。对我来讲，上半年改变最大的大概就是共享单车了。张掖路也是如此，但不是漫山遍野的自行车。为了不让单车进入，步行街的路障间隙更小了——将将够钻进去一条腿——进去以后擦一把汗，开始感慨前些日子的减肥真他丫有效，不然老夫就要卡死在这里了。</p><span id="more"></span><p>为什么念念不忘的是张掖路？除了之前总在这里买些衣服鞋子，让我逐渐摸清哪家店的沙发睡觉舒服以外，就是人多。我喜欢这里，总能让我沾沾人气儿，但又不必拘束自己。我喜欢看这里的人。</p><p>有吹着口哨吊儿郎当的“小社会”，有大包小包打招呼都腾不出手的时尚 girl，有大胆往前走绝不向两边看的外卖小哥，也有讲着今儿鸡蛋多少钱亚欧超市是不是减价的大妈大爷，更多的是手扣着手面色红润的小情侣们。手里拎本儿 Kindle，眼睛像磕睡狗一样眯起来望着这条街的，可能就只我一个了。</p><p>看着，我突然发现一个大问题——每个人，他们，居然，都，在讲话！成群结队成双成对的人在互相讲话，独自一个的人要么在讲电话，要么不知嘴里在嘟囔着什么。“怎么会这样”我自言自语。</p><p>为什么人人都会说话，为什么人人都在说话，人人都在说什么话？想回答这几个问题，着实有些难度，也很难在一篇小记中去讲。但培根问我的一个问题很有意思：“很多科学实验证明，猩猩也有语言，那么它跟人有什么不一样呢？它们有意识么？”这个问题就更有意思了。我认为解答这个问题的关键大概在于大猩猩有没有形成判断动词——是，也就是英文中的 be 动词。如果没有，那么它们还不能领会“存在”，只能通过语言表达诸存在者。在这个角度看，它们没有存在意义上的意识。再来看人类，就很有意思了。他们不仅仅可以领会经验上的存在物，更能领会超验的东西。比如——金钱、国家、社会、甚至是爱情。这些存在者的存在，没有意识，是无法领会的。</p><p>话又说回到爱情。之前看过一个理论，如果情侣之前无话可说，就很难有幸福感可言。说明充分的交流沟通是人与人之间构成伴侣的一个非常重要的条件。回过神看见商圈门前的一对对们，虽然高矮胖瘦形态各异，甚至肤色都有所不同。但都可以相爱——他们的十指都紧扣在一起，开心地讲着什么事情。</p><p>说的也巧，最近从臻那边听到了两个真实的故事。</p><p>一个是臻的父母。</p><p>他老爸最开始不会做饭，直到他妈妈怀了他，他爸就磕磕绊绊在他妈妈的指导下学习做饭，每次他妈妈晚上饿了，他爸都二话不说去做夜宵，再后来，就是他爸一直做饭了。</p><p>他爸妈也不怎么吵架，就算吵得最厉害，也不超过半个小时，他爸就问他妈要不要泡个茶歇一会儿，他妈妈也欣然同意。他有一次问起他爸妈，“问题还没解决为啥就不吵了？”他妈妈说：“其实吵架的时候就已经想好要让一些步了，反正这么多年都是这样。”他爸爸说：“和你妈一吵架，我就心疼了，她肯定也知道我的想法了，所以我还是老老实实服软吧。”</p><p>另一个是臻在旅途中还遇到的一对金婚夫妇，在他们家中借宿了一天，听到了许多他们过往的故事。</p><p>夫妻俩都很大年纪了，奶奶叫那个阿公“酷哥”，阿公叫那个奶奶“宝贝”。那天阿公晚上要出去一趟，两个人还要拥抱之后，吻一下额头，才肯分开。奶奶趁着爷爷出去，偷偷告诉臻，她这一辈子最开心的事情，就是把当年那个连一句想你都不会说的闷葫芦，变成了现在只要离开一会儿，就关切的不行，还要用爱你结尾的老小孩~</p><p>听完这些故事，当时的心情已是惘然。</p><p>现在回想，能拥有这样的爱情的人，该是有多可爱呀。一辈子不长，撞上好运气，能享受大富大贵的可能都比遇到这样一个人并且相处的如此之美的机会大太多。所以，要珍惜身边的人儿，你相信她，她相信你，两人都相信这样的生活，以后才可能就是如此了。臻，你讲，是不是这样？</p><p>自张掖路一游之后，我对黄河风情线念念不忘。所以决定沿黄河南岸分别来一次骑行和跑步。</p><p>一路上最有意思的事情莫过于穿行在沿途的广场舞们中间，伴着异域风情高难度的新疆舞（是的，兰州今年流行这个），她们根本不为所动，就像冲进了一个正在被扭曲中的魔方，此情此景用一个字来形容，就是群魔乱舞。</p><p>另外，跑步的时候我还答应了一件事：未来要和“吃货”（此处简写）一起去东营逛逛，看看共和国最年轻的那片土地。或许，那边会的是一个比我曾经想去的巴颜喀拉山更神奇的地方呢。不，两个地方都要去，一起去看看究竟哪里更是希望。此处 at 她。</p><p>在黄河北岸骑车，穿过兰州音乐厅和城市规划馆的时候，我忍不住驻足，去欣赏她们。很有意思，一个被霓虹灯过度装点而另一个是被黑夜过度吞噬。终于，兰州也不再是那片朦朦胧胧的工业灰，她变得清晰年轻性感起来。</p><p>最后，贴几张雨后兰州的照片作结束吧。</p><p><a href="/wp-content/uploads/2017/08/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170831232345.jpg"><img data-src="/wp-content/uploads/2017/08/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170831232345.jpg"></a> <a href="/wp-content/uploads/2017/08/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170831232355.jpg"><img data-src="/wp-content/uploads/2017/08/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170831232355.jpg"></a> <a href="/wp-content/uploads/2017/08/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170831232401.jpg"><img data-src="/wp-content/uploads/2017/08/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170831232401.jpg"></a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;时日已至伏末，先别问秋老虎可不可怕，仅是鼻炎已经足以让我怀疑有一个连的人在想我。&lt;/p&gt;
&lt;p&gt;话归正题，兰州在我心中的形象由两部分，一半像兰州烟上（我最喜欢吉祥兰州硬盒上的那个红色镶金的图案）那样：悠悠兰州，九天揽秀，另一半是爽朗直接，像兰州公交车司机一样，可以跳下车跟出租车对骂。总体来讲，用人来形容就是一个很飘渺但又古朴纯净的三四十岁胡子邋遢瘦削的硬汉。总之，矛盾满满。不过这一点不想展开去说，说说最近在兰州的见闻吧。&lt;/p&gt;
&lt;p&gt;按照惯例，每次回家都要去张掖路逛逛，每次去逛也都盼着能有点什么不一样，但又担心不一样的地方多了我会忘记之前是什么样子。不过到目前为止，我的担心都是多余的。对我来讲，上半年改变最大的大概就是共享单车了。张掖路也是如此，但不是漫山遍野的自行车。为了不让单车进入，步行街的路障间隙更小了——将将够钻进去一条腿——进去以后擦一把汗，开始感慨前些日子的减肥真他丫有效，不然老夫就要卡死在这里了。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://blog.zhengi.me/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="兰州" scheme="https://blog.zhengi.me/tags/%E5%85%B0%E5%B7%9E/"/>
    
  </entry>
  
  <entry>
    <title>写在二刷《摔跤吧，爸爸！》之后</title>
    <link href="https://blog.zhengi.me/watch_Dangal_twice/"/>
    <id>https://blog.zhengi.me/watch_Dangal_twice/</id>
    <published>2017-05-14T17:32:34.000Z</published>
    <updated>2024-03-23T06:03:16.947Z</updated>
    
    <content type="html"><![CDATA[<p>好电影是值得多看几遍的。</p><p>说实话，这几个月我都没有进电影院，更没有看过最近有争论所谓的这些国产烂片或者说是美国大片。对这部电影，虽然没有对比，但不能阻碍我认为它是一部好片。</p><p>虽然两次看的是同一部电影，但我每次的关注点一定是完全不同的。第一遍是随着影片的进程，不去思考过多，而是把自己融入电影之中，心情和大脑都去主动跟随剧情的发展，完全按照导演和编剧的思路欣赏。如果这是一部好片，那么心情一定会起起伏伏，倘若恰巧情节还比较紧凑，那么一场电影看下来必定是淋漓大汗。第二遍呢，我会选择从片中走出来，在看的时候去思考人物的性格、导演对情节的安排以及场内观众们的表现，看完后必定会有许多新的发现，有时候或许还能看出哪里是被引入的时候经过剪裁的，人物应该在哪里可以更活。</p><p>首刷的时候，我大概和其他观众一样，随着两个小姑娘的视角，内心跟随她们一起成长，一起对父亲肃然起敬，甚至国歌响的那一刹那，我也跟随她们一起感动。</p><p>二刷的时候，我注意到了几个有趣的细节。</p><p>第一个是父亲不顾村里人的笑话，不顾官员的嘲讽，更不顾录像厅老板的眼神，每一次出场的眼神都温和却坚定；但却因自己特殊照顾女儿却导致女儿差点被体育学校开出流泪，这是多坚强的泪水！</p><p>第二个是父亲不论是在女儿消极怠练还是她们跑去参加别人的婚礼惹他生气甚至是女儿在教练那边学到了新的技巧而趾高气昂地嫌弃他的办法老旧的时候，他都没有打过一次女儿（每次都是她们的哥哥背锅）。父亲虽然严厉，但绝不毒辣，他对女儿的爱不亚于天下任何的父亲。</p><span id="more"></span><p>第三个是我认为是一个片段可能被删减，大概是父亲应该花几句话的时间去解释一下他为了让女儿摔跤不只是为了自己的梦想，还是为了女儿摆脱印度社会对于女性的不平等，让他的女儿过得更好一些。虽然在婚礼后新娘和女孩们的对话中可以看出一些，但依旧感觉不够浓厚，毕竟从父亲口中讲出来可以让电影主题更加深化，情节也更合人物性格一些（更可以让许多认为父亲是在强加自己的意志在女儿身上的人闭嘴）。而这一点我认为在中国人的心里认同性还是挺高。感谢牛三岁提供的生动素材，比如父母让孩子学习钢琴之类的乐器，这些乐器很可能是父母年轻时候未竟的梦想，现在让孩子去学，目的不仅仅是为了让子女去为他们比赛获奖，这也是提高子女的修养，子女小时候不理解，但一定终身受益。</p><p>第四点是我惊叹到导演居然在最后一刻安排将父亲关在小房间里。这一点对吉塔的成长太重要了，如果父亲在场，吉塔能赢，但这不是她自己，而是有她父亲的一半，她的意志还是父亲用来实现理想的一个附属。但是父亲被关在小黑屋里那一刻，吉塔变成了她自己，她在荧幕中完完全全活了起来，她赢的那一刻，她是在实践去做她自己。所以我看到父亲被关进去的那一刹那（虽然已经知道情节），还是深深舒了一口气，为吉塔感到高兴。</p><p>最后一点，是细细品味后，我惊讶到这部电影一切都是恰到好处。首先，这个故事的背景几乎没有只有印度人可以看懂的印度文化，里面表现出印度专有文化的几个镜头基本不用理解就可以完全明白。再说到这个故事，本身是一个励志故事，大概就是一个被所有人看不起的穷小子成功逆袭的路线，把故事背景换到中国，换到日本，甚至换到美国，都可以找到类似的题材。第三呢，这个电影虽然反映了印度的男女不平等、童婚、甚至是官员不作为等等问题，但都是点到为止，没有一丝一毫的多余，在最后吉塔击败白人选手，印度国歌响彻电影院的那一刹那，这些批判什么都不算，这部电影的主题是爱国！但又不脑残。电影的节奏安排也非常合理，在情节最紧张的时候，观众们都屏息凝神，而几乎每一个笑点，可以让从几岁到几十岁的人都会心一笑。特别是到了吉塔最后比赛的时候，拍摄得更是精妙。我扫视一下电影院，发现虽然大家都知道最后肯定会赢，但是眼神里都是紧张二字，在每一个得分点出现的时候，我看见旁边的姑娘更是激动得和屏幕里赛场中的观众一起鼓掌（要不是这里是电影院的话可能就要欢呼出来了）。一部电影，能做到这一点太难得了。</p><p>所以，这部电影这么火，并不是偶然，它是一部每一个细节都用心雕琢的好电影。</p><p>今天也是母亲节，这部片让我想起来老妈这么多年来对我的培养。</p><p>她和片中的父亲不一样，没有严厉的要求，更从没有将她的意志加在我的肩上。我从小到大，她是我的母亲，更是我的挚友。</p><p>老妈对我的教育方式虽然和片中父亲虽然完全不同，但有着相同的胸怀。宽松的环境反倒让我可以思考得更加深入，有机会去读书去接触他人。</p><p>这些都让我从侧面更加解我自己，知道自己应该去做什么，更明白自己在做什么，更可以为自己所做的事情负责。</p><p>所以我很庆幸，我（我想父母也是）早已经过了上文中所说的吉塔父亲被关进小黑屋的那一关。</p><p>再矫情的话我也说不出了，不过此刻确实非常想给老妈一个大大的拥抱。</p><p>最后的最后，附上几张看完电影后在学校中见到的如画一样的美景吧：</p><p><a href="/wp-content/uploads/2017/05/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170515012923.jpg"><img data-src="/wp-content/uploads/2017/05/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170515012923-1024x768.jpg"></a></p><p><a href="/wp-content/uploads/2017/05/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170515012914.jpg"><img data-src="/wp-content/uploads/2017/05/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170515012914-768x1024.jpg"></a></p><p><a href="/wp-content/uploads/2017/05/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170515013156.jpg"><img data-src="/wp-content/uploads/2017/05/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170515013156-1024x768.jpg"></a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;好电影是值得多看几遍的。&lt;/p&gt;
&lt;p&gt;说实话，这几个月我都没有进电影院，更没有看过最近有争论所谓的这些国产烂片或者说是美国大片。对这部电影，虽然没有对比，但不能阻碍我认为它是一部好片。&lt;/p&gt;
&lt;p&gt;虽然两次看的是同一部电影，但我每次的关注点一定是完全不同的。第一遍是随着影片的进程，不去思考过多，而是把自己融入电影之中，心情和大脑都去主动跟随剧情的发展，完全按照导演和编剧的思路欣赏。如果这是一部好片，那么心情一定会起起伏伏，倘若恰巧情节还比较紧凑，那么一场电影看下来必定是淋漓大汗。第二遍呢，我会选择从片中走出来，在看的时候去思考人物的性格、导演对情节的安排以及场内观众们的表现，看完后必定会有许多新的发现，有时候或许还能看出哪里是被引入的时候经过剪裁的，人物应该在哪里可以更活。&lt;/p&gt;
&lt;p&gt;首刷的时候，我大概和其他观众一样，随着两个小姑娘的视角，内心跟随她们一起成长，一起对父亲肃然起敬，甚至国歌响的那一刹那，我也跟随她们一起感动。&lt;/p&gt;
&lt;p&gt;二刷的时候，我注意到了几个有趣的细节。&lt;/p&gt;
&lt;p&gt;第一个是父亲不顾村里人的笑话，不顾官员的嘲讽，更不顾录像厅老板的眼神，每一次出场的眼神都温和却坚定；但却因自己特殊照顾女儿却导致女儿差点被体育学校开出流泪，这是多坚强的泪水！&lt;/p&gt;
&lt;p&gt;第二个是父亲不论是在女儿消极怠练还是她们跑去参加别人的婚礼惹他生气甚至是女儿在教练那边学到了新的技巧而趾高气昂地嫌弃他的办法老旧的时候，他都没有打过一次女儿（每次都是她们的哥哥背锅）。父亲虽然严厉，但绝不毒辣，他对女儿的爱不亚于天下任何的父亲。&lt;/p&gt;</summary>
    
    
    
    <category term="影评" scheme="https://blog.zhengi.me/categories/%E5%BD%B1%E8%AF%84/"/>
    
    
    <category term="影评" scheme="https://blog.zhengi.me/tags/%E5%BD%B1%E8%AF%84/"/>
    
  </entry>
  
</feed>
